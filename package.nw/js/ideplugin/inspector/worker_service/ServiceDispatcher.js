class Service{dispose(){}setNotify(s){}}class ServiceDispatcher{constructor(s){this._objects=new Map,this._lastObjectId=1,this._port=s,this._port.setHandlers(this._dispatchMessageWrapped.bind(this),this._connectionClosed.bind(this))}_dispatchMessageWrapped(s){let e;try{if(e=JSON.parse(s),!(e instanceof Object))return void this._sendErrorResponse(e.id,"Malformed message");this._dispatchMessage(e)}catch(s){this._sendErrorResponse(e?e.id:"",s.toString()+" "+s.stack)}}_dispatchMessage(s){const e=s.method.split("."),t=e[0],r=e[1];if("create"===r){const e=self.runtime.extensions(Service).filter(s=>s.descriptor().name===t);if(!e.length)return void this._sendErrorResponse(s.id,"Could not resolve service '"+t+"'");e[0].instance().then(e=>{const r=String(this._lastObjectId++);e.setNotify(this._notify.bind(this,r,t)),this._objects.set(r,e),this._sendResponse(s.id,{id:r})})}else if("dispose"===r){const e=this._objects.get(s.params.id);if(!e)return void console.error("Could not look up object with id for "+JSON.stringify(s));this._objects.delete(s.params.id),e.dispose().then(()=>this._sendResponse(s.id,{}))}else{if(!s.params)return void console.error("No params in the message: "+JSON.stringify(s));const e=this._objects.get(s.params.id);if(!e)return void console.error("Could not look up object with id for "+JSON.stringify(s));if(!(e[r]instanceof Function))return void console.error("Handler for '"+r+"' is missing.");e[r](s.params).then(e=>this._sendResponse(s.id,e))}}_connectionClosed(){for(const s of this._objects.values())s.dispose();this._objects.clear()}_notify(s,e,t,r){r.id=s;const i={method:e+"."+t,params:r};this._port.send(JSON.stringify(i))}_sendResponse(s,e){const t={id:s,result:e};this._port.send(JSON.stringify(t))}_sendErrorResponse(s,e){const t={id:s,error:e};this._port.send(JSON.stringify(t))}}class WorkerServicePort{constructor(s){this._port=s,this._port.onmessage=this._onMessage.bind(this),this._port.onerror=console.error}setHandlers(s,e){this._messageHandler=s,this._closeHandler=e}send(s){return this._port.postMessage(s),Promise.resolve()}close(){return Promise.resolve()}_onMessage(s){this._messageHandler(s.data)}}const dispatchers=[],worker=self,servicePort=new WorkerServicePort(worker);dispatchers.push(new ServiceDispatcher(servicePort)),self.Service=Service;