export class Segment{constructor(e,s,t){if(e>s)throw new Error("Invalid segment");this.begin=e,this.end=s,this.data=t}intersects(e){return this.begin<e.end&&e.begin<this.end}}export class SegmentedRange{constructor(e){this._segments=[],this._mergeCallback=e}append(e){let s=this._segments.lowerBound(e,(e,s)=>e.begin-s.begin),t=s,n=null;if(s>0){const t=this._segments[s-1];n=this._tryMerge(t,e),n?(--s,e=n):this._segments[s-1].end>=e.begin&&(e.end<t.end&&this._segments.splice(s,0,new Segment(e.end,t.end,t.data)),t.end=e.begin)}for(;t<this._segments.length&&this._segments[t].end<=e.end;)++t;t<this._segments.length&&(n=this._tryMerge(e,this._segments[t]),n?(t++,e=n):e.intersects(this._segments[t])&&(this._segments[t].begin=e.end)),this._segments.splice(s,t-s,e)}appendRange(e){e.segments().forEach(e=>this.append(e))}segments(){return this._segments}_tryMerge(e,s){const t=this._mergeCallback&&this._mergeCallback(e,s);return t?(t.begin=e.begin,t.end=Math.max(e.end,s.end),t):null}}