import{EventDescriptor,EventTarget,EventTargetEvent}from"./EventTarget.js";let _listenerCallbackTuple;export class ObjectWrapper{constructor(){this._listeners}addEventListener(e,t,s){t||console.assert(!1),this._listeners||(this._listeners=new Map),this._listeners.has(e)||this._listeners.set(e,[]);const i=this._listeners.get(e);return i&&i.push({thisObject:s,listener:t,disposed:void 0}),{eventTarget:this,eventType:e,thisObject:s,listener:t}}once(e){return new Promise(t=>{const s=this.addEventListener(e,i=>{this.removeEventListener(e,s.listener),t(i.data)})})}removeEventListener(e,t,s){if(console.assert(!!t),!this._listeners||!this._listeners.has(e))return;const i=this._listeners.get(e)||[];for(let e=0;e<i.length;++e)i[e].listener===t&&i[e].thisObject===s&&(i[e].disposed=!0,i.splice(e--,1));i.length||this._listeners.delete(e)}hasEventListeners(e){return!(!this._listeners||!this._listeners.has(e))}dispatchEventToListeners(e,t){if(!this._listeners||!this._listeners.has(e))return;const s={data:t},i=this._listeners.get(e).slice(0)||[];for(let e=0;e<i.length;++e)i[e].disposed||i[e].listener.call(i[e].thisObject,s)}}