import*as Common from"../common/common.js";import*as HeapSnapshotModel from"../heap_snapshot_model/heap_snapshot_model.js";import{AllocationProfile}from"./AllocationProfile.js";import{HeapSnapshotWorkerDispatcher}from"./HeapSnapshotWorkerDispatcher.js";export class HeapSnapshotItem{itemIndex(){}serialize(){}}export class HeapSnapshotEdge{constructor(e,t){this._snapshot=e,this._edges=e.containmentEdges,this.edgeIndex=t||0}clone(){return new HeapSnapshotEdge(this._snapshot,this.edgeIndex)}hasStringName(){throw new Error("Not implemented")}name(){throw new Error("Not implemented")}node(){return this._snapshot.createNode(this.nodeIndex())}nodeIndex(){return this._edges[this.edgeIndex+this._snapshot._edgeToNodeOffset]}toString(){return"HeapSnapshotEdge: "+this.name()}type(){return this._snapshot._edgeTypes[this.rawType()]}itemIndex(){return this.edgeIndex}serialize(){return new HeapSnapshotModel.HeapSnapshotModel.Edge(this.name(),this.node().serialize(),this.type(),this.edgeIndex)}rawType(){return this._edges[this.edgeIndex+this._snapshot._edgeTypeOffset]}}export class HeapSnapshotItemIterator{hasNext(){}item(){}next(){}}export class HeapSnapshotItemIndexProvider{itemForIndex(e){}}export class HeapSnapshotNodeIndexProvider{constructor(e){this._node=e.createNode()}itemForIndex(e){return this._node.nodeIndex=e,this._node}}export class HeapSnapshotEdgeIndexProvider{constructor(e){this._edge=e.createEdge(0)}itemForIndex(e){return this._edge.edgeIndex=e,this._edge}}export class HeapSnapshotRetainerEdgeIndexProvider{constructor(e){this._retainerEdge=e.createRetainingEdge(0)}itemForIndex(e){return this._retainerEdge.setRetainerIndex(e),this._retainerEdge}}export class HeapSnapshotEdgeIterator{constructor(e){this._sourceNode=e,this.edge=e._snapshot.createEdge(e.edgeIndexesStart())}hasNext(){return this.edge.edgeIndex<this._sourceNode.edgeIndexesEnd()}item(){return this.edge}next(){this.edge.edgeIndex+=this.edge._snapshot._edgeFieldsCount}}export class HeapSnapshotRetainerEdge{constructor(e,t){this._snapshot=e,this.setRetainerIndex(t)}clone(){return new HeapSnapshotRetainerEdge(this._snapshot,this.retainerIndex())}hasStringName(){return this._edge().hasStringName()}name(){return this._edge().name()}node(){return this._node()}nodeIndex(){return this._retainingNodeIndex}retainerIndex(){return this._retainerIndex}setRetainerIndex(e){e!==this._retainerIndex&&(this._retainerIndex=e,this._globalEdgeIndex=this._snapshot._retainingEdges[e],this._retainingNodeIndex=this._snapshot._retainingNodes[e],this._edgeInstance=null,this._nodeInstance=null)}set edgeIndex(e){this.setRetainerIndex(e)}_node(){return this._nodeInstance||(this._nodeInstance=this._snapshot.createNode(this._retainingNodeIndex)),this._nodeInstance}_edge(){return this._edgeInstance||(this._edgeInstance=this._snapshot.createEdge(this._globalEdgeIndex)),this._edgeInstance}toString(){return this._edge().toString()}itemIndex(){return this._retainerIndex}serialize(){return new HeapSnapshotModel.HeapSnapshotModel.Edge(this.name(),this.node().serialize(),this.type(),this._globalEdgeIndex)}type(){return this._edge().type()}}export class HeapSnapshotRetainerEdgeIterator{constructor(e){const t=e._snapshot,s=e.ordinal(),n=t._firstRetainerIndex[s];this._retainersEnd=t._firstRetainerIndex[s+1],this.retainer=t.createRetainingEdge(n)}hasNext(){return this.retainer.retainerIndex()<this._retainersEnd}item(){return this.retainer}next(){this.retainer.setRetainerIndex(this.retainer.retainerIndex()+1)}}export class HeapSnapshotNode{constructor(e,t){this._snapshot=e,this.nodeIndex=t||0}distance(){return this._snapshot._nodeDistances[this.nodeIndex/this._snapshot._nodeFieldCount]}className(){throw new Error("Not implemented")}classIndex(){throw new Error("Not implemented")}dominatorIndex(){const e=this._snapshot._nodeFieldCount;return this._snapshot._dominatorsTree[this.nodeIndex/this._snapshot._nodeFieldCount]*e}edges(){return new HeapSnapshotEdgeIterator(this)}edgesCount(){return(this.edgeIndexesEnd()-this.edgeIndexesStart())/this._snapshot._edgeFieldsCount}id(){throw new Error("Not implemented")}isRoot(){return this.nodeIndex===this._snapshot._rootNodeIndex}name(){return this._snapshot.strings[this._name()]}retainedSize(){return this._snapshot._retainedSizes[this.ordinal()]}retainers(){return new HeapSnapshotRetainerEdgeIterator(this)}retainersCount(){const e=this._snapshot,t=this.ordinal();return e._firstRetainerIndex[t+1]-e._firstRetainerIndex[t]}selfSize(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeSelfSizeOffset]}type(){return this._snapshot._nodeTypes[this.rawType()]}traceNodeId(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeTraceNodeIdOffset]}itemIndex(){return this.nodeIndex}serialize(){return new HeapSnapshotModel.HeapSnapshotModel.Node(this.id(),this.name(),this.distance(),this.nodeIndex,this.retainedSize(),this.selfSize(),this.type())}_name(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeNameOffset]}edgeIndexesStart(){return this._snapshot._firstEdgeIndexes[this.ordinal()]}edgeIndexesEnd(){return this._snapshot._firstEdgeIndexes[this.ordinal()+1]}ordinal(){return this.nodeIndex/this._snapshot._nodeFieldCount}_nextNodeIndex(){return this.nodeIndex+this._snapshot._nodeFieldCount}rawType(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeTypeOffset]}}export class HeapSnapshotNodeIterator{constructor(e){this.node=e,this._nodesLength=e._snapshot.nodes.length}hasNext(){return this.node.nodeIndex<this._nodesLength}item(){return this.node}next(){this.node.nodeIndex=this.node._nextNodeIndex()}}export class HeapSnapshotIndexRangeIterator{constructor(e,t){this._itemProvider=e,this._indexes=t,this._position=0}hasNext(){return this._position<this._indexes.length}item(){const e=this._indexes[this._position];return this._itemProvider.itemForIndex(e)}next(){++this._position}}export class HeapSnapshotFilteredIterator{constructor(e,t){this._iterator=e,this._filter=t,this._skipFilteredItems()}hasNext(){return this._iterator.hasNext()}item(){return this._iterator.item()}next(){this._iterator.next(),this._skipFilteredItems()}_skipFilteredItems(){for(;this._iterator.hasNext()&&!this._filter(this._iterator.item());)this._iterator.next()}}export class HeapSnapshotProgress{constructor(e){this._dispatcher=e}updateStatus(e){this._sendUpdateEvent(Common.UIString.serializeUIString(e))}updateProgress(e,t,s){const n=(100*(s?t/s:0)).toFixed(0);this._sendUpdateEvent(Common.UIString.serializeUIString(e,[n]))}reportProblem(e){this._dispatcher&&this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot,e)}_sendUpdateEvent(e){this._dispatcher&&this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.Update,e)}}export class HeapSnapshotProblemReport{constructor(e){this._errors=[e]}addError(e){this._errors.length>100||this._errors.push(e)}toString(){return this._errors.join("\n  ")}}export class HeapSnapshot{constructor(e,t){this.nodes=e.nodes,this.containmentEdges=e.edges,this._metaNode=e.snapshot.meta,this._rawSamples=e.samples,this._samples=null,this.strings=e.strings,this._locations=e.locations,this._progress=t,this._noDistance=-5,this._rootNodeIndex=0,e.snapshot.root_index&&(this._rootNodeIndex=e.snapshot.root_index),this._snapshotDiffs={},this._aggregatesForDiff=null,this._aggregates={},this._aggregatesSortedFlags={},this._profile=e}initialize(){const e=this._metaNode;this._nodeTypeOffset=e.node_fields.indexOf("type"),this._nodeNameOffset=e.node_fields.indexOf("name"),this._nodeIdOffset=e.node_fields.indexOf("id"),this._nodeSelfSizeOffset=e.node_fields.indexOf("self_size"),this._nodeEdgeCountOffset=e.node_fields.indexOf("edge_count"),this._nodeTraceNodeIdOffset=e.node_fields.indexOf("trace_node_id"),this._nodeFieldCount=e.node_fields.length,this._nodeTypes=e.node_types[this._nodeTypeOffset],this._nodeArrayType=this._nodeTypes.indexOf("array"),this._nodeHiddenType=this._nodeTypes.indexOf("hidden"),this._nodeObjectType=this._nodeTypes.indexOf("object"),this._nodeNativeType=this._nodeTypes.indexOf("native"),this._nodeConsStringType=this._nodeTypes.indexOf("concatenated string"),this._nodeSlicedStringType=this._nodeTypes.indexOf("sliced string"),this._nodeCodeType=this._nodeTypes.indexOf("code"),this._nodeSyntheticType=this._nodeTypes.indexOf("synthetic"),this._edgeFieldsCount=e.edge_fields.length,this._edgeTypeOffset=e.edge_fields.indexOf("type"),this._edgeNameOffset=e.edge_fields.indexOf("name_or_index"),this._edgeToNodeOffset=e.edge_fields.indexOf("to_node"),this._edgeTypes=e.edge_types[this._edgeTypeOffset],this._edgeTypes.push("invisible"),this._edgeElementType=this._edgeTypes.indexOf("element"),this._edgeHiddenType=this._edgeTypes.indexOf("hidden"),this._edgeInternalType=this._edgeTypes.indexOf("internal"),this._edgeShortcutType=this._edgeTypes.indexOf("shortcut"),this._edgeWeakType=this._edgeTypes.indexOf("weak"),this._edgeInvisibleType=this._edgeTypes.indexOf("invisible");const t=e.location_fields||[];this._locationIndexOffset=t.indexOf("object_index"),this._locationScriptIdOffset=t.indexOf("script_id"),this._locationLineOffset=t.indexOf("line"),this._locationColumnOffset=t.indexOf("column"),this._locationFieldCount=t.length,this.nodeCount=this.nodes.length/this._nodeFieldCount,this._edgeCount=this.containmentEdges.length/this._edgeFieldsCount,this._retainedSizes=new Float64Array(this.nodeCount),this._firstEdgeIndexes=new Uint32Array(this.nodeCount+1),this._retainingNodes=new Uint32Array(this._edgeCount),this._retainingEdges=new Uint32Array(this._edgeCount),this._firstRetainerIndex=new Uint32Array(this.nodeCount+1),this._nodeDistances=new Int32Array(this.nodeCount),this._firstDominatedNodeIndex=new Uint32Array(this.nodeCount+1),this._dominatedNodes=new Uint32Array(this.nodeCount-1),this._progress.updateStatus(ls`Building edge indexes…`),this._buildEdgeIndexes(),this._progress.updateStatus(ls`Building retainers…`),this._buildRetainers(),this._progress.updateStatus(ls`Calculating node flags…`),this.calculateFlags(),this._progress.updateStatus(ls`Calculating distances…`),this.calculateDistances(),this._progress.updateStatus(ls`Building postorder index…`);const s=this._buildPostOrderIndex();if(this._progress.updateStatus(ls`Building dominator tree…`),this._dominatorsTree=this._buildDominatorTree(s.postOrderIndex2NodeOrdinal,s.nodeOrdinal2PostOrderIndex),this._progress.updateStatus(ls`Calculating retained sizes…`),this._calculateRetainedSizes(s.postOrderIndex2NodeOrdinal),this._progress.updateStatus(ls`Building dominated nodes…`),this._buildDominatedNodes(),this._progress.updateStatus(ls`Calculating statistics…`),this.calculateStatistics(),this._progress.updateStatus(ls`Calculating samples…`),this._buildSamples(),this._progress.updateStatus(ls`Building locations…`),this._buildLocationMap(),this._progress.updateStatus(ls`Finished processing.`),this._profile.snapshot.trace_function_count){this._progress.updateStatus(ls`Building allocation statistics…`);const e=this.nodes.length,t=this._nodeFieldCount,s=this.rootNode(),n={};for(let i=0;i<e;i+=t){s.nodeIndex=i;const e=s.traceNodeId();let t=n[e];t||(n[e]=t={count:0,size:0,ids:[]}),t.count++,t.size+=s.selfSize(),t.ids.push(s.id())}this._allocationProfile=new AllocationProfile(this._profile,n),this._progress.updateStatus(ls`Done`)}}_buildEdgeIndexes(){const e=this.nodes,t=this.nodeCount,s=this._firstEdgeIndexes,n=this._nodeFieldCount,i=this._edgeFieldsCount,o=this._nodeEdgeCountOffset;s[t]=this.containmentEdges.length;for(let r=0,d=0;r<t;++r)s[r]=d,d+=e[r*n+o]*i}_buildRetainers(){const e=this._retainingNodes,t=this._retainingEdges,s=this._firstRetainerIndex,n=this.containmentEdges,i=this._edgeFieldsCount,o=this._nodeFieldCount,r=this._edgeToNodeOffset,d=this._firstEdgeIndexes,a=this.nodeCount;for(let e=r,t=n.length;e<t;e+=i){const t=n[e];if(t%o)throw new Error("Invalid toNodeIndex "+t);++s[t/o]}for(let t=0,n=0;t<a;t++){const i=s[t];s[t]=n,e[n]=i,n+=i}s[a]=e.length;let h=d[0];for(let l=0;l<a;++l){const a=h;h=d[l+1];const _=l*o;for(let d=a;d<h;d+=i){const i=n[d+r];if(i%o)throw new Error("Invalid toNodeIndex "+i);const a=s[i/o],h=a+--e[a];e[h]=_,t[h]=d}}}createNode(e){throw new Error("Not implemented")}createEdge(e){throw new Error("Not implemented")}createRetainingEdge(e){throw new Error("Not implemented")}_allNodes(){return new HeapSnapshotNodeIterator(this.rootNode())}rootNode(){return this.createNode(this._rootNodeIndex)}get rootNodeIndex(){return this._rootNodeIndex}get totalSize(){return this.rootNode().retainedSize()}_getDominatedIndex(e){if(e%this._nodeFieldCount)throw new Error("Invalid nodeIndex: "+e);return this._firstDominatedNodeIndex[e/this._nodeFieldCount]}_createFilter(e){const t=e.minNodeId,s=e.maxNodeId,n=e.allocationNodeId;let i;return"number"==typeof n?(i=this._createAllocationStackFilter(n),i.key="AllocationNodeId: "+n):"number"==typeof t&&"number"==typeof s&&(i=this._createNodeIdFilter(t,s),i.key="NodeIdRange: "+t+".."+s),i}search(e,t){const s=e.query;const n=e.isRegex?new RegExp(s):createPlainTextSearchRegex(s,"i");const i=e.isRegex||!e.caseSensitive?function(e,t,s){return n.test(t)&&e.add(s),e}:function(e,t,n){return-1!==t.indexOf(s)&&e.add(n),e},o=this.strings.reduce(i,new Set);if(!o.size)return[];const r=this._createFilter(t),d=[],a=this.nodes.length,h=this.nodes,l=this._nodeNameOffset,_=this._nodeIdOffset,c=this._nodeFieldCount,p=this.rootNode();for(let e=0;e<a;e+=c)p.nodeIndex=e,r&&!r(p)||o.has(h[e+l])&&d.push(h[e+_]);return d}aggregatesWithFilter(e){const t=this._createFilter(e),s=t?t.key:"allObjects";return this.aggregates(!1,s,t)}_createNodeIdFilter(e,t){return function(s){const n=s.id();return n>e&&n<=t}}_createAllocationStackFilter(e){const t=this._allocationProfile.traceIds(e);if(!t.length)return;const s={};for(let e=0;e<t.length;e++)s[t[e]]=!0;return function(e){return!!s[e.traceNodeId()]}}aggregates(e,t,s){let n=t&&this._aggregates[t];if(!n){const e=this._buildAggregates(s);this._calculateClassesRetainedSize(e.aggregatesByClassIndex,s),n=e.aggregatesByClassName,t&&(this._aggregates[t]=n)}return!e||t&&this._aggregatesSortedFlags[t]||(this._sortAggregateIndexes(n),t&&(this._aggregatesSortedFlags[t]=e)),n}allocationTracesTops(){return this._allocationProfile.serializeTraceTops()}allocationNodeCallers(e){return this._allocationProfile.serializeCallers(e)}allocationStack(e){const t=this.createNode(e).traceNodeId();return t?this._allocationProfile.serializeAllocationStack(t):null}aggregatesForDiff(){if(this._aggregatesForDiff)return this._aggregatesForDiff;const e=this.aggregates(!0,"allObjects");this._aggregatesForDiff={};const t=this.createNode();for(const s in e){const n=e[s].idxs,i=new Array(n.length),o=new Array(n.length);for(let e=0;e<n.length;e++)t.nodeIndex=n[e],i[e]=t.id(),o[e]=t.selfSize();this._aggregatesForDiff[s]={indexes:n,ids:i,selfSizes:o}}return this._aggregatesForDiff}isUserRoot(e){return!0}calculateDistances(e){const t=this.nodeCount,s=this._nodeDistances,n=this._noDistance;for(let e=0;e<t;++e)s[e]=n;const i=new Uint32Array(this.nodeCount);let o=0;for(let e=this.rootNode().edges();e.hasNext();e.next()){const t=e.edge.node();this.isUserRoot(t)&&(s[t.ordinal()]=1,i[o++]=t.nodeIndex)}this._bfs(i,o,s,e),s[this.rootNode().ordinal()]=o>0?HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance:0,i[0]=this.rootNode().nodeIndex,o=1,this._bfs(i,o,s,e)}_bfs(e,t,s,n){const i=this._edgeFieldsCount,o=this._nodeFieldCount,r=this.containmentEdges,d=this._firstEdgeIndexes,a=this._edgeToNodeOffset,h=this._edgeTypeOffset,l=this.nodeCount,_=this._edgeWeakType,c=this._noDistance;let p=0;const g=this.createEdge(0),u=this.createNode(0);for(;p<t;){const l=e[p++],f=l/o,x=s[f]+1,m=d[f],I=d[f+1];u.nodeIndex=l;for(let d=m;d<I;d+=i){if(r[d+h]===_)continue;const i=r[d+a],l=i/o;s[l]===c&&(g.edgeIndex=d,n&&!n(u,g)||(s[l]=x,e[t++]=i))}}if(t>l)throw new Error("BFS failed. Nodes to visit ("+t+") is more than nodes count ("+l+")")}_buildAggregates(e){const t={},s={},n=[],i=this.nodes,o=i.length,r=this._nodeNativeType,d=this._nodeFieldCount,a=this._nodeSelfSizeOffset,h=this._nodeTypeOffset,l=this.rootNode(),_=this._nodeDistances;for(let c=0;c<o;c+=d){if(l.nodeIndex=c,e&&!e(l))continue;const o=i[c+a];if(!o&&i[c+h]!==r)continue;const p=l.classIndex(),g=_[c/d];if(p in t){const e=t[p];e.distance=Math.min(e.distance,g),++e.count,e.self+=o,e.idxs.push(c)}else{const e=l.type(),i={count:1,distance:g,self:o,maxRet:0,type:e,name:"object"===e||"native"===e?l.name():null,idxs:[c]};t[p]=i,n.push(p),s[l.className()]=i}}for(let e=0,s=n.length;e<s;++e){const s=n[e];t[s].idxs=t[s].idxs.slice()}return{aggregatesByClassName:s,aggregatesByClassIndex:t}}_calculateClassesRetainedSize(e,t){const s=this._rootNodeIndex,n=this.createNode(s),i=[s],o=[-1],r=[],d={},a=this._nodeFieldCount,h=this._nodeTypeOffset,l=this._nodeNativeType,_=this._dominatedNodes,c=this.nodes,p=this._firstDominatedNodeIndex;for(;i.length;){const s=i.pop();n.nodeIndex=s;let g=n.classIndex();const u=!!d[g],f=s/a,x=p[f],m=p[f+1];u||t&&!t(n)||!n.selfSize()&&c[s+h]!==l||(e[g].maxRet+=n.retainedSize(),x!==m&&(d[g]=!0,o.push(i.length),r.push(g)));for(let e=x;e<m;e++)i.push(_[e]);const I=i.length;for(;o[o.length-1]===I;)o.pop(),g=r.pop(),d[g]=!1}}_sortAggregateIndexes(e){const t=this.createNode(),s=this.createNode();for(const n in e)e[n].idxs.sort((e,n)=>(t.nodeIndex=e,s.nodeIndex=n,t.id()<s.id()?-1:1))}_isEssentialEdge(e,t){return t!==this._edgeWeakType&&(t!==this._edgeShortcutType||e===this._rootNodeIndex)}_buildPostOrderIndex(){const e=this._nodeFieldCount,t=this.nodeCount,s=this._rootNodeIndex/e,n=this._edgeFieldsCount,i=this._edgeTypeOffset,o=this._edgeToNodeOffset,r=this._firstEdgeIndexes,d=this.containmentEdges,a=this.userObjectsMapAndFlag(),h=a?a.map:null,l=a?a.flag:0,_=new Uint32Array(t),c=new Uint32Array(t),p=new Uint32Array(t),g=new Uint32Array(t),u=new Uint8Array(t);let f=0,x=0;_[0]=s,c[0]=r[s],u[s]=1;let m=0;for(;;){for(++m;x>=0;){const t=_[x],a=c[x];if(a<r[t+1]){c[x]+=n;const p=d[a+i];if(!this._isEssentialEdge(t*e,p))continue;const g=d[a+o]/e;if(u[g])continue;const f=!h||h[t]&l,m=!h||h[g]&l;if(t!==s&&m&&!f)continue;++x,_[x]=g,c[x]=r[g],u[g]=1}else g[t]=f,p[f++]=t,--x}if(f===t||m>1)break;const a=new HeapSnapshotProblemReport(`Heap snapshot: ${t-f} nodes are unreachable from the root. Following nodes have only weak retainers:`),I=this.rootNode();--f,x=0,_[0]=s,c[0]=r[s+1];for(let s=0;s<t;++s){if(u[s]||!this._hasOnlyWeakRetainers(s))continue;_[++x]=s,c[x]=r[s],u[s]=1,I.nodeIndex=s*e;const t=[];for(let e=I.retainers();e.hasNext();e.next())t.push(`${e.item().node().name()}@${e.item().node().id()}.${e.item().name()}`);a.addError(`${I.name()} @${I.id()}  weak retainers: ${t.join(", ")}`)}console.warn(a.toString())}if(f!==t){const n=new HeapSnapshotProblemReport("Still found "+(t-f)+" unreachable nodes in heap snapshot:"),i=this.rootNode();--f;for(let s=0;s<t;++s)u[s]||(i.nodeIndex=s*e,n.addError(i.name()+" @"+i.id()),g[s]=f,p[f++]=s);g[s]=f,p[f++]=s,console.warn(n.toString())}return{postOrderIndex2NodeOrdinal:p,nodeOrdinal2PostOrderIndex:g}}_hasOnlyWeakRetainers(e){const t=this._edgeTypeOffset,s=this._edgeWeakType,n=this._edgeShortcutType,i=this.containmentEdges,o=this._retainingEdges,r=this._firstRetainerIndex[e],d=this._firstRetainerIndex[e+1];for(let e=r;e<d;++e){const r=i[o[e]+t];if(r!==s&&r!==n)return!1}return!0}_buildDominatorTree(e,t){const s=this._nodeFieldCount,n=this._firstRetainerIndex,i=this._retainingNodes,o=this._retainingEdges,r=this._edgeFieldsCount,d=this._edgeTypeOffset,a=this._edgeToNodeOffset,h=this._firstEdgeIndexes,l=this.containmentEdges,_=this._rootNodeIndex,c=this.userObjectsMapAndFlag(),p=c?c.map:null,g=c?c.flag:0,u=e.length,f=u-1,x=u,m=new Uint32Array(u);for(let e=0;e<f;++e)m[e]=x;m[f]=f;const I=new Uint8Array(u);let S;{S=this._rootNodeIndex/s;const e=h[S+1];for(let n=h[S];n<e;n+=r){const e=l[n+d];if(!this._isEssentialEdge(this._rootNodeIndex,e))continue;I[t[l[n+a]/s]]=1}}let N=!0;for(;N;){N=!1;for(let c=f-1;c>=0;--c){if(0===I[c])continue;if(I[c]=0,m[c]===f)continue;S=e[c];const u=!p||p[S]&g;let y=x;const O=n[S],T=n[S+1];let E=!0;for(let e=O;e<T;++e){const n=l[o[e]+d],r=i[e];if(!this._isEssentialEdge(r,n))continue;E=!1;const a=r/s,h=!p||p[a]&g;if(r!==_&&u&&!h)continue;let c=t[a];if(m[c]!==x){if(y===x)y=c;else for(;c!==y;){for(;c<y;)c=m[c];for(;y<c;)y=m[y]}if(y===f)break}}if(E&&(y=f),y!==x&&m[c]!==y){m[c]=y,N=!0,S=e[c];const n=h[S]+a,i=h[S+1];for(let e=n;e<i;e+=r){I[t[l[e]/s]]=1}}}}const y=new Uint32Array(u);for(let t=0,s=m.length;t<s;++t)S=e[t],y[S]=e[m[t]];return y}_calculateRetainedSizes(e){const t=this.nodeCount,s=this.nodes,n=this._nodeSelfSizeOffset,i=this._nodeFieldCount,o=this._dominatorsTree,r=this._retainedSizes;for(let e=0;e<t;++e)r[e]=s[e*i+n];for(let s=0;s<t-1;++s){const t=e[s];r[o[t]]+=r[t]}}_buildDominatedNodes(){const e=this._firstDominatedNodeIndex,t=this._dominatedNodes,s=this._nodeFieldCount,n=this._dominatorsTree;let i=0,o=this.nodeCount;const r=this._rootNodeIndex/s;if(r===i)i=1;else{if(r!==o-1)throw new Error("Root node is expected to be either first or last");o-=1}for(let t=i;t<o;++t)++e[n[t]];let d=0;for(let s=0,n=this.nodeCount;s<n;++s){const n=t[d]=e[s];e[s]=d,d+=n}e[this.nodeCount]=t.length;for(let r=i;r<o;++r){let i=e[n[r]];i+=--t[i],t[i]=r*s}}_buildSamples(){const e=this._rawSamples;if(!e||!e.length)return;const t=e.length/2,s=new Array(t),n=new Array(t),i=new Array(t),o=this._metaNode.sample_fields.indexOf("timestamp_us"),r=this._metaNode.sample_fields.indexOf("last_assigned_id");for(let d=0;d<t;d++)s[d]=0,n[d]=e[2*d+o]/1e3,i[d]=e[2*d+r];const d=this.nodes.length,a=this._nodeFieldCount,h=this.rootNode();for(let e=0;e<d;e+=a){h.nodeIndex=e;const n=h.id();if(n%2==0)continue;const o=i.lowerBound(n);o!==t&&(s[o]+=h.selfSize())}this._samples=new HeapSnapshotModel.HeapSnapshotModel.Samples(n,i,s)}_buildLocationMap(){const e=new Map,t=this._locations;for(let s=0;s<t.length;s+=this._locationFieldCount){const n=t[s+this._locationIndexOffset],i=t[s+this._locationScriptIdOffset],o=t[s+this._locationLineOffset],r=t[s+this._locationColumnOffset];e.set(n,new HeapSnapshotModel.HeapSnapshotModel.Location(i,o,r))}this._locationMap=e}getLocation(e){return this._locationMap.get(e)||null}getSamples(){return this._samples}calculateFlags(){throw new Error("Not implemented")}calculateStatistics(){throw new Error("Not implemented")}userObjectsMapAndFlag(){throw new Error("Not implemented")}calculateSnapshotDiff(e,t){let s=this._snapshotDiffs[e];if(s)return s;s={};const n=this.aggregates(!0,"allObjects");for(const e in t){const i=t[e],o=this._calculateDiffForClass(i,n[e]);o&&(s[e]=o)}const i=new HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff;for(const e in n)e in t||(s[e]=this._calculateDiffForClass(i,n[e]));return this._snapshotDiffs[e]=s,s}_calculateDiffForClass(e,t){const s=e.ids,n=e.indexes,i=e.selfSizes,o=t?t.idxs:[];let r=0,d=0;const a=s.length,h=o.length,l=new HeapSnapshotModel.HeapSnapshotModel.Diff,_=this.createNode(o[d]);for(;r<a&&d<h;){const e=s[r];e<_.id()?(l.deletedIndexes.push(n[r]),l.removedCount++,l.removedSize+=i[r],++r):e>_.id()?(l.addedIndexes.push(o[d]),l.addedCount++,l.addedSize+=_.selfSize(),_.nodeIndex=o[++d]):(++r,_.nodeIndex=o[++d])}for(;r<a;)l.deletedIndexes.push(n[r]),l.removedCount++,l.removedSize+=i[r],++r;for(;d<h;)l.addedIndexes.push(o[d]),l.addedCount++,l.addedSize+=_.selfSize(),_.nodeIndex=o[++d];return l.countDelta=l.addedCount-l.removedCount,l.sizeDelta=l.addedSize-l.removedSize,l.addedCount||l.removedCount?l:null}_nodeForSnapshotObjectId(e){for(let t=this._allNodes();t.hasNext();t.next())if(t.node.id()===e)return t.node;return null}nodeClassName(e){const t=this._nodeForSnapshotObjectId(e);return t?t.className():null}idsOfObjectsWithName(e){const t=[];for(let s=this._allNodes();s.hasNext();s.next())s.item().name()===e&&t.push(s.item().id());return t}createEdgesProvider(e){const t=this.createNode(e),s=this.containmentEdgesFilter(),n=new HeapSnapshotEdgeIndexProvider(this);return new HeapSnapshotEdgesProvider(this,s,t.edges(),n)}createEdgesProviderForTest(e,t){const s=this.createNode(e),n=new HeapSnapshotEdgeIndexProvider(this);return new HeapSnapshotEdgesProvider(this,t,s.edges(),n)}retainingEdgesFilter(){return null}containmentEdgesFilter(){return null}createRetainingEdgesProvider(e){const t=this.createNode(e),s=this.retainingEdgesFilter(),n=new HeapSnapshotRetainerEdgeIndexProvider(this);return new HeapSnapshotEdgesProvider(this,s,t.retainers(),n)}createAddedNodesProvider(e,t){const s=this._snapshotDiffs[e][t];return new HeapSnapshotNodesProvider(this,s.addedIndexes)}createDeletedNodesProvider(e){return new HeapSnapshotNodesProvider(this,e)}createNodesProviderForClass(e,t){return new HeapSnapshotNodesProvider(this,this.aggregatesWithFilter(t)[e].idxs)}_maxJsNodeId(){const e=this._nodeFieldCount,t=this.nodes,s=t.length;let n=0;for(let i=this._nodeIdOffset;i<s;i+=e){const e=t[i];e%2!=0&&(n<e&&(n=e))}return n}updateStaticData(){return new HeapSnapshotModel.HeapSnapshotModel.StaticData(this.nodeCount,this._rootNodeIndex,this.totalSize,this._maxJsNodeId())}}const HeapSnapshotMetainfo=class{constructor(){this.node_fields=[],this.node_types=[],this.edge_fields=[],this.edge_types=[],this.trace_function_info_fields=[],this.trace_node_fields=[],this.sample_fields=[],this.type_strings={}}};export class HeapSnapshotHeader{constructor(){this.title="",this.meta=new HeapSnapshotMetainfo,this.node_count=0,this.edge_count=0,this.trace_function_count=0}}export class HeapSnapshotItemProvider{constructor(e,t){this._iterator=e,this._indexProvider=t,this._isEmpty=!e.hasNext(),this._iterationOrder=null,this._currentComparator=null,this._sortedPrefixLength=0,this._sortedSuffixLength=0}_createIterationOrder(){if(!this._iterationOrder){this._iterationOrder=[];for(let e=this._iterator;e.hasNext();e.next())this._iterationOrder.push(e.item().itemIndex())}}isEmpty(){return this._isEmpty}serializeItemsRange(e,t){if(this._createIterationOrder(),e>t)throw new Error("Start position > end position: "+e+" > "+t);t>this._iterationOrder.length&&(t=this._iterationOrder.length),this._sortedPrefixLength<t&&e<this._iterationOrder.length-this._sortedSuffixLength&&(this.sort(this._currentComparator,this._sortedPrefixLength,this._iterationOrder.length-1-this._sortedSuffixLength,e,t-1),e<=this._sortedPrefixLength&&(this._sortedPrefixLength=t),t>=this._iterationOrder.length-this._sortedSuffixLength&&(this._sortedSuffixLength=this._iterationOrder.length-e));let s=e;const n=t-e,i=new Array(n);for(let e=0;e<n;++e){const t=this._iterationOrder[s++],n=this._indexProvider.itemForIndex(t);i[e]=n.serialize()}return new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(e,t,this._iterationOrder.length,i)}sortAndRewind(e){this._currentComparator=e,this._sortedPrefixLength=0,this._sortedSuffixLength=0}}export class HeapSnapshotEdgesProvider extends HeapSnapshotItemProvider{constructor(e,t,s,n){super(t?new HeapSnapshotFilteredIterator(s,t):s,n),this.snapshot=e}sort(e,t,s,n,i){const o=e.fieldName1,r=e.fieldName2,d=e.ascending1,a=e.ascending2,h=this._iterator.item().clone(),l=h.clone(),_=this.snapshot.createNode(),c=this.snapshot.createNode();function p(e,t,s){if(h.edgeIndex=t,l.edgeIndex=s,"__proto__"===l.name())return-1;if("__proto__"===h.name())return 1;const n=h.hasStringName()===l.hasStringName()?h.name()<l.name()?-1:h.name()>l.name()?1:0:h.hasStringName()?-1:1;return e?n:-n}function g(e,t,s,n){h.edgeIndex=s,_.nodeIndex=h.nodeIndex();const i=_[e]();l.edgeIndex=n,c.nodeIndex=l.nodeIndex();const o=c[e](),r=i<o?-1:i>o?1:0;return t?r:-r}"!edgeName"===o?this._iterationOrder.sortRange((function(e,t){let s=p(d,e,t);return 0===s&&(s=g(r,a,e,t)),0===s?e-t:s}),t,s,n,i):"!edgeName"===r?this._iterationOrder.sortRange((function(e,t){let s=g(o,d,e,t);return 0===s&&(s=p(a,e,t)),0===s?e-t:s}),t,s,n,i):this._iterationOrder.sortRange((function(e,t){let s=g(o,d,e,t);return 0===s&&(s=g(r,a,e,t)),0===s?e-t:s}),t,s,n,i)}}export class HeapSnapshotNodesProvider extends HeapSnapshotItemProvider{constructor(e,t){const s=new HeapSnapshotNodeIndexProvider(e);super(new HeapSnapshotIndexRangeIterator(s,t),s),this.snapshot=e}nodePosition(e){this._createIterationOrder();const t=this.snapshot.createNode();let s=0;for(;s<this._iterationOrder.length&&(t.nodeIndex=this._iterationOrder[s],t.id()!==e);s++);if(s===this._iterationOrder.length)return-1;const n=this._iterationOrder[s];let i=0;const o=this._buildCompareFunction(this._currentComparator);for(let e=0;e<this._iterationOrder.length;e++)o(this._iterationOrder[e],n)<0&&++i;return i}_buildCompareFunction(e){const t=this.snapshot.createNode(),s=this.snapshot.createNode(),n=t[e.fieldName1],i=t[e.fieldName2],o=e.ascending1?1:-1,r=e.ascending2?1:-1;function d(e,n){const i=e.call(t),o=e.call(s);return i<o?-n:i>o?n:0}return function(e,a){t.nodeIndex=e,s.nodeIndex=a;let h=d(n,o);return 0===h&&(h=d(i,r)),h||e-a}}sort(e,t,s,n,i){this._iterationOrder.sortRange(this._buildCompareFunction(e),t,s,n,i)}}export class JSHeapSnapshot extends HeapSnapshot{constructor(e,t){super(e,t),this._nodeFlags={canBeQueried:1,detachedDOMTreeNode:2,pageObject:4},this._lazyStringCache={},this.initialize()}createNode(e){return new JSHeapSnapshotNode(this,void 0===e?-1:e)}createEdge(e){return new JSHeapSnapshotEdge(this,e)}createRetainingEdge(e){return new JSHeapSnapshotRetainerEdge(this,e)}containmentEdgesFilter(){return e=>!e.isInvisible()}retainingEdgesFilter(){const e=this.containmentEdgesFilter();return function(t){return e(t)&&!t.node().isRoot()&&!t.isWeak()}}calculateFlags(){this._flags=new Uint32Array(this.nodeCount),this._markDetachedDOMTreeNodes(),this._markQueriableHeapObjects(),this._markPageOwnedNodes()}calculateDistances(){super.calculateDistances((function(e,t){if(e.isHidden())return"sloppy_function_map"!==t.name()||"system / NativeContext"!==e.rawName();if(e.isArray()){if("(map descriptors)"!==e.rawName())return!0;const s=t.name();return s<2||s%3!=1}return!0}))}isUserRoot(e){return e.isUserRoot()||e.isDocumentDOMTreesRoot()}userObjectsMapAndFlag(){return{map:this._flags,flag:this._nodeFlags.pageObject}}_flagsOfNode(e){return this._flags[e.nodeIndex/this._nodeFieldCount]}_markDetachedDOMTreeNodes(){const e=this.nodes,t=e.length,s=this._nodeFieldCount,n=this._nodeNativeType,i=this._nodeTypeOffset,o=this._nodeFlags.detachedDOMTreeNode,r=this.rootNode();for(let d=0,a=0;d<t;d+=s,a++){e[d+i]===n&&(r.nodeIndex=d,r.name().startsWith("Detached ")&&(this._flags[a]|=o))}}_markQueriableHeapObjects(){const e=this._nodeFlags.canBeQueried,t=this._edgeHiddenType,s=this._edgeInternalType,n=this._edgeInvisibleType,i=this._edgeWeakType,o=this._edgeToNodeOffset,r=this._edgeTypeOffset,d=this._edgeFieldsCount,a=this.containmentEdges,h=this._nodeFieldCount,l=this._firstEdgeIndexes,_=this._flags,c=[];for(let e=this.rootNode().edges();e.hasNext();e.next())e.edge.node().isUserRoot()&&c.push(e.edge.node().nodeIndex/h);for(;c.length;){const p=c.pop();if(_[p]&e)continue;_[p]|=e;const g=l[p],u=l[p+1];for(let l=g;l<u;l+=d){const d=a[l+o]/h;if(_[d]&e)continue;const p=a[l+r];p!==t&&p!==n&&p!==s&&p!==i&&c.push(d)}}}_markPageOwnedNodes(){const e=this._edgeShortcutType,t=this._edgeElementType,s=this._edgeToNodeOffset,n=this._edgeTypeOffset,i=this._edgeFieldsCount,o=this._edgeWeakType,r=this._firstEdgeIndexes,d=this.containmentEdges,a=this._nodeFieldCount,h=this.nodeCount,l=this._flags,_=this._nodeFlags.pageObject,c=new Uint32Array(h);let p=0;const g=this._rootNodeIndex/a,u=this.rootNode();for(let o=r[g],h=r[g+1];o<h;o+=i){const i=d[o+n],r=d[o+s];if(i===t){if(u.nodeIndex=r,!u.isDocumentDOMTreesRoot())continue}else if(i!==e)continue;const h=r/a;c[p++]=h,l[h]|=_}for(;p;){const e=c[--p],t=r[e],h=r[e+1];for(let e=t;e<h;e+=i){const t=d[e+s]/a;if(l[t]&_)continue;d[e+n]!==o&&(c[p++]=t,l[t]|=_)}}}calculateStatistics(){const e=this._nodeFieldCount,t=this.nodes,s=t.length,n=this._nodeTypeOffset,i=this._nodeSelfSizeOffset,o=this._nodeNativeType,r=this._nodeCodeType,d=this._nodeConsStringType,a=this._nodeSlicedStringType,h=this._nodeDistances;let l=0,_=0,c=0,p=0,g=0;const u=this.rootNode();for(let f=0;f<s;f+=e){const s=t[f+i];if(h[f/e]>=HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance){g+=s;continue}const x=t[f+n];u.nodeIndex=f,x===o?l+=s:x===r?_+=s:x===d||x===a||"string"===u.type()?c+=s:"Array"===u.name()&&(p+=this._calculateArraySize(u))}this._statistics=new HeapSnapshotModel.HeapSnapshotModel.Statistics,this._statistics.total=this.totalSize,this._statistics.v8heap=this.totalSize-l,this._statistics.native=l,this._statistics.code=_,this._statistics.jsArrays=p,this._statistics.strings=c,this._statistics.system=g}_calculateArraySize(e){let t=e.selfSize();const s=e.edgeIndexesStart(),n=e.edgeIndexesEnd(),i=this.containmentEdges,o=this.strings,r=this._edgeToNodeOffset,d=this._edgeTypeOffset,a=this._edgeNameOffset,h=this._edgeFieldsCount,l=this._edgeInternalType;for(let _=s;_<n;_+=h){if(i[_+d]!==l)continue;if("elements"!==o[i[_+a]])continue;const s=i[_+r];e.nodeIndex=s,1===e.retainersCount()&&(t+=e.selfSize());break}return t}getStatistics(){return this._statistics}}export class JSHeapSnapshotNode extends HeapSnapshotNode{constructor(e,t){super(e,t)}canBeQueried(){return!!(this._snapshot._flagsOfNode(this)&this._snapshot._nodeFlags.canBeQueried)}rawName(){return super.name()}name(){const e=this._snapshot;if(this.rawType()===e._nodeConsStringType){let t=e._lazyStringCache[this.nodeIndex];return void 0===t&&(t=this._consStringName(),e._lazyStringCache[this.nodeIndex]=t),t}return this.rawName()}_consStringName(){const e=this._snapshot,t=e._nodeConsStringType,s=e._edgeInternalType,n=e._edgeFieldsCount,i=e._edgeToNodeOffset,o=e._edgeTypeOffset,r=e._edgeNameOffset,d=e.strings,a=e.containmentEdges,h=e._firstEdgeIndexes,l=e._nodeFieldCount,_=e._nodeTypeOffset,c=e._nodeNameOffset,p=e.nodes,g=[];g.push(this.nodeIndex);let u="";for(;g.length&&u.length<1024;){const e=g.pop();if(p[e+_]!==t){u+=d[p[e+c]];continue}const f=e/l,x=h[f],m=h[f+1];let I=0,S=0;for(let e=x;e<m&&(!I||!S);e+=n){if(a[e+o]===s){const t=d[a[e+r]];"first"===t?I=a[e+i]:"second"===t&&(S=a[e+i])}}g.push(S),g.push(I)}return u}className(){const e=this.type();switch(e){case"hidden":return"(system)";case"object":case"native":return this.name();case"code":return"(compiled code)";default:return"("+e+")"}}classIndex(){const e=this._snapshot,t=e.nodes,s=t[this.nodeIndex+e._nodeTypeOffset];return s===e._nodeObjectType||s===e._nodeNativeType?t[this.nodeIndex+e._nodeNameOffset]:-1-s}id(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeIdOffset]}isHidden(){return this.rawType()===this._snapshot._nodeHiddenType}isArray(){return this.rawType()===this._snapshot._nodeArrayType}isSynthetic(){return this.rawType()===this._snapshot._nodeSyntheticType}isUserRoot(){return!this.isSynthetic()}isDocumentDOMTreesRoot(){return this.isSynthetic()&&"(Document DOM trees)"===this.name()}serialize(){const e=super.serialize(),t=this._snapshot._flagsOfNode(this);return t&this._snapshot._nodeFlags.canBeQueried&&(e.canBeQueried=!0),t&this._snapshot._nodeFlags.detachedDOMTreeNode&&(e.detachedDOMTreeNode=!0),e}}export class JSHeapSnapshotEdge extends HeapSnapshotEdge{constructor(e,t){super(e,t)}clone(){const e=this._snapshot;return new JSHeapSnapshotEdge(e,this.edgeIndex)}hasStringName(){return this.isShortcut()?isNaN(parseInt(this._name(),10)):this._hasStringName()}isElement(){return this.rawType()===this._snapshot._edgeElementType}isHidden(){return this.rawType()===this._snapshot._edgeHiddenType}isWeak(){return this.rawType()===this._snapshot._edgeWeakType}isInternal(){return this.rawType()===this._snapshot._edgeInternalType}isInvisible(){return this.rawType()===this._snapshot._edgeInvisibleType}isShortcut(){return this.rawType()===this._snapshot._edgeShortcutType}name(){const e=this._name();if(!this.isShortcut())return String(e);const t=parseInt(e,10);return String(isNaN(t)?e:t)}toString(){const e=this.name();switch(this.type()){case"context":return"->"+e;case"element":return"["+e+"]";case"weak":return"[["+e+"]]";case"property":return-1===e.indexOf(" ")?"."+e:'["'+e+'"]';case"shortcut":return"string"==typeof e?-1===e.indexOf(" ")?"."+e:'["'+e+'"]':"["+e+"]";case"internal":case"hidden":case"invisible":return"{"+e+"}"}return"?"+e+"?"}_hasStringName(){const e=this.rawType(),t=this._snapshot;return e!==t._edgeElementType&&e!==t._edgeHiddenType}_name(){return this._hasStringName()?this._snapshot.strings[this._nameOrIndex()]:this._nameOrIndex()}_nameOrIndex(){return this._edges[this.edgeIndex+this._snapshot._edgeNameOffset]}rawType(){return this._edges[this.edgeIndex+this._snapshot._edgeTypeOffset]}}export class JSHeapSnapshotRetainerEdge extends HeapSnapshotRetainerEdge{constructor(e,t){super(e,t)}clone(){const e=this._snapshot;return new JSHeapSnapshotRetainerEdge(e,this.retainerIndex())}isHidden(){return this._edge().isHidden()}isInternal(){return this._edge().isInternal()}isInvisible(){return this._edge().isInvisible()}isShortcut(){return this._edge().isShortcut()}isWeak(){return this._edge().isWeak()}}self.Root&&self.Root.Runtime&&Root.Runtime.queryParam("test")&&(console.warn=()=>{});export let AggregatedInfo;