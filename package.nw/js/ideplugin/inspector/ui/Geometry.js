export const _Eps=1e-5;export class Vector{constructor(t,e,i){this.x=t,this.y=e,this.z=i}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}normalize(){const t=this.length();t<=_Eps||(this.x/=t,this.y/=t,this.z/=t)}}export class Point{constructor(t,e){this.x=t,this.y=e}distanceTo(t){return Math.sqrt(Math.pow(t.x-this.x,2)+Math.pow(t.y-this.y,2))}projectOn(t){return 0===t.x&&0===t.y?new Point(0,0):t.scale((this.x*t.x+this.y*t.y)/(Math.pow(t.x,2)+Math.pow(t.y,2)))}scale(t){return new Point(this.x*t,this.y*t)}toString(){return Math.round(100*this.x)/100+", "+Math.round(100*this.y)/100}}export class CubicBezier{constructor(t,e){this.controlPoints=[t,e]}static parse(t){const e=CubicBezier.KeywordValues,i=t.toLowerCase().replace(/\s+/g,"");if(-1!==Object.keys(e).indexOf(i))return CubicBezier.parse(e[i]);const r=i.match(/^cubic-bezier\(([^,]+),([^,]+),([^,]+),([^,]+)\)$/);if(r){const t=new Point(parseFloat(r[1]),parseFloat(r[2])),e=new Point(parseFloat(r[3]),parseFloat(r[4]));return new CubicBezier(t,e)}return null}evaluateAt(t){function e(t,e,i){return 3*(1-i)*(1-i)*i*t+3*(1-i)*i*i*e+Math.pow(i,3)}const i=e(this.controlPoints[0].x,this.controlPoints[1].x,t),r=e(this.controlPoints[0].y,this.controlPoints[1].y,t);return new Point(i,r)}asCSSText(){const t="cubic-bezier("+this.controlPoints.join(", ")+")",e=CubicBezier.KeywordValues;for(const i in e)if(t===e[i])return i;return t}}CubicBezier.Regex=/((cubic-bezier\([^)]+\))|\b(linear|ease-in-out|ease-in|ease-out|ease)\b)/g,CubicBezier.KeywordValues={linear:"cubic-bezier(0, 0, 1, 1)",ease:"cubic-bezier(0.25, 0.1, 0.25, 1)","ease-in":"cubic-bezier(0.42, 0, 1, 1)","ease-in-out":"cubic-bezier(0.42, 0, 0.58, 1)","ease-out":"cubic-bezier(0, 0, 0.58, 1)"};export class EulerAngles{constructor(t,e,i){this.alpha=t,this.beta=e,this.gamma=i}static fromRotationMatrix(t){const e=Math.atan2(t.m23,t.m33),i=Math.atan2(-t.m13,Math.sqrt(t.m11*t.m11+t.m12*t.m12)),r=Math.atan2(t.m12,t.m11);return new EulerAngles(radiansToDegrees(r),radiansToDegrees(e),radiansToDegrees(i))}toRotate3DString(){const t={alpha:[0,1,0],beta:[-1,0,0],gamma:[0,-Math.sin(degreesToRadians(this.beta)),Math.cos(degreesToRadians(this.beta))]};return"rotate3d("+t.alpha.join(",")+","+this.alpha+"deg) rotate3d("+t.beta.join(",")+","+this.beta+"deg) rotate3d("+t.gamma.join(",")+","+this.gamma+"deg)"}}export const scalarProduct=function(t,e){return t.x*e.x+t.y*e.y+t.z*e.z};export const crossProduct=function(t,e){const i=t.y*e.z-t.z*e.y,r=t.z*e.x-t.x*e.z,s=t.x*e.y-t.y*e.x;return new Vector(i,r,s)};export const subtract=function(t,e){const i=t.x-e.x,r=t.y-e.y,s=t.z-e.z;return new Vector(i,r,s)};export const multiplyVectorByMatrixAndNormalize=function(t,e){const i=t.x*e.m14+t.y*e.m24+t.z*e.m34+e.m44,r=(t.x*e.m11+t.y*e.m21+t.z*e.m31+e.m41)/i,s=(t.x*e.m12+t.y*e.m22+t.z*e.m32+e.m42)/i,n=(t.x*e.m13+t.y*e.m23+t.z*e.m33+e.m43)/i;return new Vector(r,s,n)};export const calculateAngle=function(t,e){const i=t.length(),r=e.length();if(i<=_Eps||r<=_Eps)return 0;const s=scalarProduct(t,e)/i/r;return Math.abs(s)>1?0:radiansToDegrees(Math.acos(s))};export const degreesToRadians=function(t){return t*Math.PI/180};export const radiansToDegrees=function(t){return 180*t/Math.PI};export const boundsForTransformedPoints=function(t,e,i){i||(i={minX:1/0,maxX:-1/0,minY:1/0,maxY:-1/0}),e.length%3&&console.assert("Invalid size of points array");for(let r=0;r<e.length;r+=3){let s=new Vector(e[r],e[r+1],e[r+2]);s=multiplyVectorByMatrixAndNormalize(s,t),i.minX=Math.min(i.minX,s.x),i.maxX=Math.max(i.maxX,s.x),i.minY=Math.min(i.minY,s.y),i.maxY=Math.max(i.maxY,s.y)}return i};export class Size{constructor(t,e){this.width=t,this.height=e}clipTo(t){return t?new Size(Math.min(this.width,t.width),Math.min(this.height,t.height)):this}scale(t){return new Size(this.width*t,this.height*t)}isEqual(t){return!!t&&this.width===t.width&&this.height===t.height}widthToMax(t){return new Size(Math.max(this.width,"number"==typeof t?t:t.width),this.height)}addWidth(t){return new Size(this.width+("number"==typeof t?t:t.width),this.height)}heightToMax(t){return new Size(this.width,Math.max(this.height,"number"==typeof t?t:t.height))}addHeight(t){return new Size(this.width,this.height+("number"==typeof t?t:t.height))}}export class Insets{constructor(t,e,i,r){this.left=t,this.top=e,this.right=i,this.bottom=r}isEqual(t){return!!t&&this.left===t.left&&this.top===t.top&&this.right===t.right&&this.bottom===t.bottom}}export class Rect{constructor(t,e,i,r){this.left=t,this.top=e,this.width=i,this.height=r}isEqual(t){return!!t&&this.left===t.left&&this.top===t.top&&this.width===t.width&&this.height===t.height}scale(t){return new Rect(this.left*t,this.top*t,this.width*t,this.height*t)}size(){return new Size(this.width,this.height)}relativeTo(t){return new Rect(this.left-t.left,this.top-t.top,this.width,this.height)}rebaseTo(t){return new Rect(this.left+t.left,this.top+t.top,this.width,this.height)}}export class Constraints{constructor(t,e){if(this.minimum=t||new Size(0,0),this.preferred=e||this.minimum,this.minimum.width>this.preferred.width||this.minimum.height>this.preferred.height)throw new Error("Minimum size is greater than preferred.")}isEqual(t){return!!t&&this.minimum.isEqual(t.minimum)&&this.preferred.isEqual(t.preferred)}widthToMax(t){return"number"==typeof t?new Constraints(this.minimum.widthToMax(t),this.preferred.widthToMax(t)):new Constraints(this.minimum.widthToMax(t.minimum),this.preferred.widthToMax(t.preferred))}addWidth(t){return"number"==typeof t?new Constraints(this.minimum.addWidth(t),this.preferred.addWidth(t)):new Constraints(this.minimum.addWidth(t.minimum),this.preferred.addWidth(t.preferred))}heightToMax(t){return"number"==typeof t?new Constraints(this.minimum.heightToMax(t),this.preferred.heightToMax(t)):new Constraints(this.minimum.heightToMax(t.minimum),this.preferred.heightToMax(t.preferred))}addHeight(t){return"number"==typeof t?new Constraints(this.minimum.addHeight(t),this.preferred.addHeight(t)):new Constraints(this.minimum.addHeight(t.minimum),this.preferred.addHeight(t.preferred))}}