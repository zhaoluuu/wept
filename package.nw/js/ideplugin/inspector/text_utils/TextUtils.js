import{SearchMatch}from"./ContentProvider.js";import{Text}from"./Text.js";export const Utils={get _keyValueFilterRegex(){return/(?:^|\s)(\-)?([\w\-]+):([^\s]+)/},get _regexFilterRegex(){return/(?:^|\s)(\-)?\/([^\s]+)\//},get _textFilterRegex(){return/(?:^|\s)(\-)?([^\s]+)/},get _SpaceCharRegex(){return/\s/},get Indent(){return{TwoSpaces:"  ",FourSpaces:"    ",EightSpaces:"        ",TabCharacter:"\t"}},isStopChar:function(e){return e>" "&&e<"0"||e>"9"&&e<"A"||e>"Z"&&e<"_"||e>"_"&&e<"a"||e>"z"&&e<="~"},isWordChar:function(e){return!Utils.isStopChar(e)&&!Utils.isSpaceChar(e)},isSpaceChar:function(e){return Utils._SpaceCharRegex.test(e)},isWord:function(e){for(let t=0;t<e.length;++t)if(!Utils.isWordChar(e.charAt(t)))return!1;return!0},isOpeningBraceChar:function(e){return"("===e||"{"===e},isClosingBraceChar:function(e){return")"===e||"}"===e},isBraceChar:function(e){return Utils.isOpeningBraceChar(e)||Utils.isClosingBraceChar(e)},textToWords:function(e,t,r){let n=-1;for(let i=0;i<e.length;++i)t(e.charAt(i))?-1===n&&(n=i):(-1!==n&&r(e.substring(n,i)),n=-1);-1!==n&&r(e.substring(n))},lineIndent:function(e){let t=0;for(;t<e.length&&Utils.isSpaceChar(e.charAt(t));)++t;return e.substr(0,t)},isUpperCase:function(e){return e===e.toUpperCase()},isLowerCase:function(e){return e===e.toLowerCase()},splitStringByRegexes(e,t){const r=[],n=[];for(let e=0;e<t.length;e++){const r=t[e];r.global?n.push(r):n.push(new RegExp(r.source,r.flags?r.flags+"g":"g"))}return function e(t,i,s){if(i>=n.length)return void r.push({value:t,position:s,regexIndex:-1,captureGroups:[]});const a=n[i];let l,o=0;a.lastIndex=0;for(;null!==(l=a.exec(t));){const n=t.substring(o,l.index);n&&e(n,i+1,s+o);const a=l[0];r.push({value:a,position:s+l.index,regexIndex:i,captureGroups:l.slice(1)}),o=l.index+a.length}const c=t.substring(o);c&&e(c,i+1,s+o)}(e,0,0),r}};export class FilterParser{constructor(e){this._keys=e}static cloneFilter(e){return{key:e.key,text:e.text,regex:e.regex,negative:e.negative}}parse(e){const t=Utils.splitStringByRegexes(e,[Utils._keyValueFilterRegex,Utils._regexFilterRegex,Utils._textFilterRegex]),r=[];for(let e=0;e<t.length;e++){const n=t[e].regexIndex;if(-1===n)continue;const i=t[e].captureGroups;if(0===n)-1!==this._keys.indexOf(i[1])?r.push({key:i[1],regex:void 0,text:i[2],negative:!!i[0]}):r.push({key:void 0,regex:void 0,text:i[1]+":"+i[2],negative:!!i[0]});else if(1===n)try{r.push({key:void 0,regex:new RegExp(i[1],"i"),text:void 0,negative:!!i[0]})}catch(e){r.push({key:void 0,regex:void 0,text:"/"+i[1]+"/",negative:!!i[0]})}else 2===n&&r.push({key:void 0,regex:void 0,text:i[1],negative:!!i[0]})}return r}}export class BalancedJSONTokenizer{constructor(e,t){this._callback=e,this._index=0,this._balance=0,this._buffer="",this._findMultiple=t||!1,this._closingDoubleQuoteRegex=/[^\\](?:\\\\)*"/g}write(e){this._buffer+=e;const t=this._buffer.length,r=this._buffer;let n;for(n=this._index;n<t;++n){const e=r[n];if('"'===e){if(this._closingDoubleQuoteRegex.lastIndex=n,!this._closingDoubleQuoteRegex.test(r))break;n=this._closingDoubleQuoteRegex.lastIndex-1}else if("{"===e)++this._balance;else if("}"===e){if(--this._balance,this._balance<0)return this._reportBalanced(),!1;if(!this._balance&&(this._lastBalancedIndex=n+1,!this._findMultiple))break}else if("]"===e&&!this._balance)return this._reportBalanced(),!1}return this._index=n,this._reportBalanced(),!0}_reportBalanced(){this._lastBalancedIndex&&(this._callback(this._buffer.slice(0,this._lastBalancedIndex)),this._buffer=this._buffer.slice(this._lastBalancedIndex),this._index-=this._lastBalancedIndex,this._lastBalancedIndex=0)}remainder(){return this._buffer}}export class TokenizerFactory{createTokenizer(e){throw new Error("not implemented")}}export function isMinified(e){let t=10,r=0;do{let t=e.indexOf("\n",r);if(t<0&&(t=e.length),t-r>500&&"//#"!==e.substr(r,3))return!0;r=t+1}while(--t>=0&&r<e.length);t=10,r=e.length;do{let t=e.lastIndexOf("\n",r);if(t<0&&(t=0),r-t>500&&"//#"!==e.substr(r,3))return!0;r=t-1}while(--t>=0&&r>0);return!1}export const performSearchInContent=function(e,t,r,n){const i=createSearchRegex(t,r,n),s=new Text(e),a=[];for(let e=0;e<s.lineCount();++e){const t=s.lineAt(e);i.lastIndex=0,i.exec(t)&&a.push(new SearchMatch(e,t))}return a};export let ParsedFilter;