import*as Common from"../common/common.js";import*as Platform from"../platform/platform.js";import*as SDK from"../sdk/sdk.js";import*as UI from"../ui/ui.js";import{LayerSelection,LayerView,LayerViewHost,ScrollRectSelection,Selection,SnapshotSelection,Type}from"./LayerViewHost.js";import{Events as TransformControllerEvents,TransformController}from"./TransformController.js";export class Layers3DView extends UI.Widget.VBox{constructor(e){super(!0),this.registerRequiredCSS("layer_viewer/layers3DView.css"),this.contentElement.classList.add("layers-3d-view"),this._failBanner=new UI.Widget.VBox,this._failBanner.element.classList.add("full-widget-dimmed-banner"),this._failBanner.element.createTextChild(Common.UIString.UIString("Layer information is not yet available.")),this._layerViewHost=e,this._layerViewHost.registerView(this),this._transformController=new TransformController(this.contentElement),this._transformController.addEventListener(TransformControllerEvents.TransformChanged,this._update,this),this._initToolbar(),this._canvasElement=this.contentElement.createChild("canvas"),this._canvasElement.tabIndex=0,this._canvasElement.addEventListener("dblclick",this._onDoubleClick.bind(this),!1),this._canvasElement.addEventListener("mousedown",this._onMouseDown.bind(this),!1),this._canvasElement.addEventListener("mouseup",this._onMouseUp.bind(this),!1),this._canvasElement.addEventListener("mouseleave",this._onMouseMove.bind(this),!1),this._canvasElement.addEventListener("mousemove",this._onMouseMove.bind(this),!1),this._canvasElement.addEventListener("contextmenu",this._onContextMenu.bind(this),!1),UI.ARIAUtils.setAccessibleName(this._canvasElement,ls`3D Layers View`),this._lastSelection={},this._layerTree=null,this._textureManager=new LayerTextureManager(this._update.bind(this)),this._chromeTextures=[],this._rects=[],this._snapshotLayers=new Map,this._layerViewHost.setLayerSnapshotMap(this._snapshotLayers),this._layerViewHost.showInternalLayersSetting().addChangeListener(this._update,this)}setLayerTree(e){this._layerTree=e,this._layerTexture=null,delete this._oldTextureScale,this._showPaints()&&this._textureManager.setLayerTree(e),this._update()}showImageForLayer(e,t){if(!t)return this._layerTexture=null,void this._update();UI.UIUtils.loadImage(t).then(t=>{const r=t&&LayerTextureManager._createTextureForImage(this._gl,t);this._layerTexture=r?{layer:e,texture:r}:null,this._update()})}onResize(){this._resizeCanvas(),this._update()}willHide(){this._textureManager.suspend()}wasShown(){this._textureManager.resume(),this._needsUpdate&&(this._resizeCanvas(),this._update())}updateLayerSnapshot(e){this._textureManager.layerNeedsUpdate(e)}_setOutline(e,t){this._lastSelection[e]=t,this._update()}hoverObject(e){this._setOutline(OutlineType.Hovered,e)}selectObject(e){this._setOutline(OutlineType.Hovered,null),this._setOutline(OutlineType.Selected,e)}snapshotForSelection(e){if(e.type()===Type.Snapshot){const t=e.snapshot();return t.snapshot.addReference(),Promise.resolve(t)}if(e.layer()){const t=e.layer().snapshots()[0];if(t)return t}return Promise.resolve(null)}_initGL(e){const t=e.getContext("webgl");return t?(t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),t.enable(t.BLEND),t.clearColor(0,0,0,0),t.enable(t.DEPTH_TEST),t):null}_createShader(e,t){const r=this._gl.createShader(e);this._gl.shaderSource(r,t),this._gl.compileShader(r),this._gl.attachShader(this._shaderProgram,r)}_initShaders(){this._shaderProgram=this._gl.createProgram(),this._createShader(this._gl.FRAGMENT_SHADER,FragmentShader),this._createShader(this._gl.VERTEX_SHADER,VertexShader),this._gl.linkProgram(this._shaderProgram),this._gl.useProgram(this._shaderProgram),this._shaderProgram.vertexPositionAttribute=this._gl.getAttribLocation(this._shaderProgram,"aVertexPosition"),this._gl.enableVertexAttribArray(this._shaderProgram.vertexPositionAttribute),this._shaderProgram.vertexColorAttribute=this._gl.getAttribLocation(this._shaderProgram,"aVertexColor"),this._gl.enableVertexAttribArray(this._shaderProgram.vertexColorAttribute),this._shaderProgram.textureCoordAttribute=this._gl.getAttribLocation(this._shaderProgram,"aTextureCoord"),this._gl.enableVertexAttribArray(this._shaderProgram.textureCoordAttribute),this._shaderProgram.pMatrixUniform=this._gl.getUniformLocation(this._shaderProgram,"uPMatrix"),this._shaderProgram.samplerUniform=this._gl.getUniformLocation(this._shaderProgram,"uSampler")}_resizeCanvas(){this._canvasElement.width=this._canvasElement.offsetWidth*window.devicePixelRatio,this._canvasElement.height=this._canvasElement.offsetHeight*window.devicePixelRatio}_updateTransformAndConstraints(){const e=this._layerTree.viewportSize(),t=e?e.width:this._dimensionsForAutoscale.width,r=e?e.height:this._dimensionsForAutoscale.height,i=this._canvasElement.width,s=this._canvasElement.height,o=.1*i,a=.1*s,n=(i-2*o)/t,l=(s-2*a)/r,h=Math.min(n,l),c=Math.min(t/this._dimensionsForAutoscale.width,r/this._dimensionsForAutoscale.width)/2;this._transformController.setScaleConstraints(c,10/h);const _=this._transformController.scale(),d=this._transformController.rotateX(),u=this._transformController.rotateY();this._scale=_*h;const m=Platform.NumberUtilities.clamp(this._scale,.1,1);m!==this._oldTextureScale&&(this._oldTextureScale=m,this._textureManager.setScale(m),this.dispatchEventToListeners(Events.ScaleChanged,m));const g=(new WebKitCSSMatrix).scale(_,_,_).translate(i/2,s/2,0).rotate(d,u,0).scale(h,h,h).translate(-t/2,-r/2,0);let p;for(let e=0;e<this._rects.length;++e)p=UI.Geometry.boundsForTransformedPoints(g,this._rects[e].vertices,p);this._transformController.clampOffsets((o-p.maxX)/window.devicePixelRatio,(i-o-p.minX)/window.devicePixelRatio,(a-p.maxY)/window.devicePixelRatio,(s-a-p.minY)/window.devicePixelRatio);const x=this._transformController.offsetX()*window.devicePixelRatio,y=this._transformController.offsetY()*window.devicePixelRatio;this._projectionMatrix=(new WebKitCSSMatrix).translate(x,y,0).multiply(g);const T=(new WebKitCSSMatrix).scale(1,-1,-1).translate(-1,-1,0).scale(2/this._canvasElement.width,2/this._canvasElement.height,1e-6).multiply(this._projectionMatrix);this._gl.uniformMatrix4fv(this._shaderProgram.pMatrixUniform,!1,this._arrayFromMatrix(T))}_arrayFromMatrix(e){return new Float32Array([e.m11,e.m12,e.m13,e.m14,e.m21,e.m22,e.m23,e.m24,e.m31,e.m32,e.m33,e.m34,e.m41,e.m42,e.m43,e.m44])}_initWhiteTexture(){this._whiteTexture=this._gl.createTexture(),this._gl.bindTexture(this._gl.TEXTURE_2D,this._whiteTexture);const e=new Uint8Array([255,255,255,255]);this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,1,1,0,this._gl.RGBA,this._gl.UNSIGNED_BYTE,e)}_initChromeTextures(){function e(e,t){UI.UIUtils.loadImage(t).then(t=>{this._chromeTextures[e]=t&&LayerTextureManager._createTextureForImage(this._gl,t)||void 0})}e.call(this,ChromeTexture.Left,"Images/chromeLeft.png"),e.call(this,ChromeTexture.Middle,"Images/chromeMiddle.png"),e.call(this,ChromeTexture.Right,"Images/chromeRight.png")}_initGLIfNecessary(){return this._gl?this._gl:(this._gl=this._initGL(this._canvasElement),this._gl?(this._initShaders(),this._initWhiteTexture(),this._initChromeTextures(),this._textureManager.setContext(this._gl),this._gl):null)}_calculateDepthsAndVisibility(){this._depthByLayerId={};let e=0;const t=this._layerViewHost.showInternalLayersSetting().get(),r=t?this._layerTree.root():this._layerTree.contentRoot()||this._layerTree.root(),i=[r];for(this._depthByLayerId[r.id()]=0,this._visibleLayers=new Set;i.length>0;){const r=i.shift();(t||r.drawsContent())&&this._visibleLayers.add(r);const s=r.children();for(let t=0;t<s.length;++t)this._depthByLayerId[s[t].id()]=++e,i.push(s[t])}this._maxDepth=e}_depthForLayer(e){return this._depthByLayerId[e.id()]*LayerSpacing}_calculateScrollRectDepth(e,t){return this._depthForLayer(e)+t*ScrollRectSpacing+1}_updateDimensionsForAutoscale(e){this._dimensionsForAutoscale.width=Math.max(e.width(),this._dimensionsForAutoscale.width),this._dimensionsForAutoscale.height=Math.max(e.height(),this._dimensionsForAutoscale.height)}_calculateLayerRect(e){if(!this._visibleLayers.has(e))return;const t=new LayerSelection(e),r=new Rectangle(t);r.setVertices(e.quad(),this._depthForLayer(e)),this._appendRect(r),this._updateDimensionsForAutoscale(e)}_appendRect(e){const t=e.relatedObject,r=Selection.isEqual(this._lastSelection[OutlineType.Selected],t),i=Selection.isEqual(this._lastSelection[OutlineType.Hovered],t);if(r)e.borderColor=SelectedBorderColor;else if(i){e.borderColor=HoveredBorderColor;const t=e.fillColor||[255,255,255,1],r=HoveredImageMaskColor;e.fillColor=[t[0]*r[0]/255,t[1]*r[1]/255,t[2]*r[2]/255,t[3]*r[3]]}else e.borderColor=BorderColor;e.lineWidth=r?SelectedBorderWidth:BorderWidth,this._rects.push(e)}_calculateLayerScrollRects(e){const t=e.scrollRects();for(let r=0;r<t.length;++r){const i=new ScrollRectSelection(e,r),s=new Rectangle(i);s.calculateVerticesFromRect(e,t[r].rect,this._calculateScrollRectDepth(e,r)),s.fillColor=ScrollRectBackgroundColor,this._appendRect(s)}}_calculateLayerTileRects(e){const t=this._textureManager.tilesForLayer(e);for(let r=0;r<t.length;++r){const i=t[r];if(!i.texture)continue;const s=new SnapshotSelection(e,{rect:i.rect,snapshot:i.snapshot}),o=new Rectangle(s);this._snapshotLayers.has(e)||this._snapshotLayers.set(e,s),o.calculateVerticesFromRect(e,i.rect,this._depthForLayer(e)+1),o.texture=i.texture,this._appendRect(o)}}_calculateRects(){if(this._rects=[],this._snapshotLayers.clear(),this._dimensionsForAutoscale={width:0,height:0},this._layerTree.forEachLayer(this._calculateLayerRect.bind(this)),this._showSlowScrollRectsSetting.get()&&this._layerTree.forEachLayer(this._calculateLayerScrollRects.bind(this)),this._layerTexture&&this._visibleLayers.has(this._layerTexture.layer)){const e=this._layerTexture.layer,t=new LayerSelection(e),r=new Rectangle(t);r.setVertices(e.quad(),this._depthForLayer(e)),r.texture=this._layerTexture.texture,this._appendRect(r)}else this._showPaints()&&this._layerTree.forEachLayer(this._calculateLayerTileRects.bind(this))}_makeColorsArray(e){let t=[];const r=[e[0]/255,e[1]/255,e[2]/255,e[3]];for(let e=0;e<4;e++)t=t.concat(r);return t}_setVertexAttribute(e,t,r){const i=this._gl,s=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,s),i.bufferData(i.ARRAY_BUFFER,new Float32Array(t),i.STATIC_DRAW),i.vertexAttribPointer(e,r,i.FLOAT,!1,0,0)}_drawRectangle(e,t,r,i){const s=this._gl;r=r||[255,255,255,1],this._setVertexAttribute(this._shaderProgram.vertexPositionAttribute,e,3),this._setVertexAttribute(this._shaderProgram.textureCoordAttribute,[0,1,1,1,1,0,0,0],2),this._setVertexAttribute(this._shaderProgram.vertexColorAttribute,this._makeColorsArray(r),r.length),i?(s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,i),s.uniform1i(this._shaderProgram.samplerUniform,0)):s.bindTexture(s.TEXTURE_2D,this._whiteTexture);const o=e.length/3;s.drawArrays(t,0,o)}_drawTexture(e,t,r){this._drawRectangle(e,this._gl.TRIANGLE_FAN,r,t)}_drawViewportAndChrome(){const e=this._layerTree.viewportSize();if(!e)return;const t=!Common.Settings.Settings.instance().moduleSetting("frameViewerHideChromeWindow").get()&&this._chromeTextures.length>=3&&this._chromeTextures.indexOf(void 0)<0,r=(this._maxDepth+1)*LayerSpacing,i=Math.ceil(ViewportBorderWidth*this._scale);let s=[e.width,0,r,e.width,e.height,r,0,e.height,r,0,0,r];if(this._gl.lineWidth(i),this._drawRectangle(s,t?this._gl.LINE_STRIP:this._gl.LINE_LOOP,ViewportBorderColor),!t)return;const o=ViewportBorderWidth/2,a=this._layerTree.viewportSize().width+2*o,n=this._chromeTextures[0].image.naturalHeight,l=a-this._chromeTextures[0].image.naturalWidth-this._chromeTextures[2].image.naturalWidth;let h=-o;const c=-n;for(let e=0;e<this._chromeTextures.length;++e){const t=e===ChromeTexture.Middle?l:this._chromeTextures[e].image.naturalWidth;if(t<0||h+t>a)break;s=[h,c,r,h+t,c,r,h+t,c+n,r,h,c+n,r],this._drawTexture(s,this._chromeTextures[e]),h+=t}}_drawViewRect(e){const t=e.vertices;e.texture?this._drawTexture(t,e.texture,e.fillColor||void 0):e.fillColor&&this._drawRectangle(t,this._gl.TRIANGLE_FAN,e.fillColor),this._gl.lineWidth(e.lineWidth),e.borderColor&&this._drawRectangle(t,this._gl.LINE_LOOP,e.borderColor)}_update(){if(!this.isShowing())return void(this._needsUpdate=!0);if(!this._layerTree||!this._layerTree.root())return void this._failBanner.show(this.contentElement);const e=this._initGLIfNecessary();if(!e)return this._failBanner.element.removeChildren(),this._failBanner.element.appendChild(this._webglDisabledBanner()),void this._failBanner.show(this.contentElement);this._failBanner.detach(),this._gl.viewportWidth=this._canvasElement.width,this._gl.viewportHeight=this._canvasElement.height,this._calculateDepthsAndVisibility(),this._calculateRects(),this._updateTransformAndConstraints(),e.viewport(0,0,e.viewportWidth,e.viewportHeight),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),this._rects.forEach(this._drawViewRect.bind(this)),this._drawViewportAndChrome()}_webglDisabledBanner(){const e=this.contentElement.ownerDocument.createDocumentFragment();return e.createChild("div").textContent=Common.UIString.UIString("Can't display layers,"),e.createChild("div").textContent=Common.UIString.UIString("WebGL support is disabled in your browser."),e.appendChild(UI.UIUtils.formatLocalized("Check %s for possible reasons.",[UI.XLink.XLink.create("about:gpu")])),e}_selectionFromEventPoint(e){if(!this._layerTree)return null;let t=1/0,r=null;const i=(new WebKitCSSMatrix).scale(1,-1,-1).translate(-1,-1,0).multiply(this._projectionMatrix),s=(e.clientX-this._canvasElement.totalOffsetLeft())*window.devicePixelRatio,o=-(e.clientY-this._canvasElement.totalOffsetTop())*window.devicePixelRatio;return this._rects.forEach((function(e){if(!e.relatedObject)return;const a=e.intersectWithLine(i,s,o);a<t&&(t=a,r=e.relatedObject)})),r}_createVisibilitySetting(e,t,r,i){const s=Common.Settings.Settings.instance().createSetting(t,r);return s.setTitle(Common.UIString.UIString(e)),s.addChangeListener(this._update,this),i.appendToolbarItem(new UI.Toolbar.ToolbarSettingCheckbox(s)),s}_initToolbar(){this._panelToolbar=this._transformController.toolbar(),this.contentElement.appendChild(this._panelToolbar.element),this._showSlowScrollRectsSetting=this._createVisibilitySetting(ls`Slow scroll rects`,"frameViewerShowSlowScrollRects",!0,this._panelToolbar),this._showPaintsSetting=this._createVisibilitySetting(ls`Paints`,"frameViewerShowPaints",!0,this._panelToolbar),this._showPaintsSetting.addChangeListener(this._updatePaints,this),Common.Settings.Settings.instance().moduleSetting("frameViewerHideChromeWindow").addChangeListener(this._update,this)}_onContextMenu(e){const t=new UI.ContextMenu.ContextMenu(e);t.defaultSection().appendItem(Common.UIString.UIString("Reset View"),this._transformController.resetAndNotify.bind(this._transformController),!1);const r=this._selectionFromEventPoint(e);r&&r.type()===Type.Snapshot&&t.defaultSection().appendItem(Common.UIString.UIString("Show Paint Profiler"),this.dispatchEventToListeners.bind(this,Events.PaintProfilerRequested,r),!1),this._layerViewHost.showContextMenu(t,r)}_onMouseMove(e){e.which||this._layerViewHost.hoverObject(this._selectionFromEventPoint(e))}_onMouseDown(e){this._mouseDownX=e.clientX,this._mouseDownY=e.clientY}_onMouseUp(e){this._mouseDownX&&Math.abs(e.clientX-this._mouseDownX)<6&&Math.abs(e.clientY-this._mouseDownY)<6&&this._layerViewHost.selectObject(this._selectionFromEventPoint(e)),delete this._mouseDownX,delete this._mouseDownY}_onDoubleClick(e){const t=this._selectionFromEventPoint(e);t&&(t.type()===Type.Snapshot||t.layer())&&this.dispatchEventToListeners(Events.PaintProfilerRequested,t),e.stopPropagation()}_updatePaints(){this._showPaints()?(this._textureManager.setLayerTree(this._layerTree),this._textureManager.forceUpdate()):this._textureManager.reset(),this._update()}_showPaints(){return this._showPaintsSetting.get()}}export const OutlineType={Hovered:"hovered",Selected:"selected"};export const Events={PaintProfilerRequested:Symbol("PaintProfilerRequested"),ScaleChanged:Symbol("ScaleChanged")};export const ChromeTexture={Left:0,Middle:1,Right:2};export const ScrollRectTitles={RepaintsOnScroll:Common.UIString.UIString("repaints on scroll"),TouchEventHandler:Common.UIString.UIString("touch event listener"),WheelEventHandler:Common.UIString.UIString("mousewheel event listener")};export const FragmentShader="precision mediump float;\nvarying vec4 vColor;\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * vColor;\n}";export const VertexShader="attribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aVertexColor;\nuniform mat4 uPMatrix;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvoid main(void)\n{\ngl_Position = uPMatrix * vec4(aVertexPosition, 1.0);\nvColor = aVertexColor;\nvTextureCoord = aTextureCoord;\n}";export const HoveredBorderColor=[0,0,255,1];export const SelectedBorderColor=[0,255,0,1];export const BorderColor=[0,0,0,1];export const ViewportBorderColor=[160,160,160,1];export const ScrollRectBackgroundColor=[178,100,100,.6];export const HoveredImageMaskColor=[200,200,255,1];export const BorderWidth=1;export const SelectedBorderWidth=2;export const ViewportBorderWidth=3;export const LayerSpacing=20;export const ScrollRectSpacing=4;export class LayerTextureManager{constructor(e){this._textureUpdatedCallback=e,this._throttler=new Common.Throttler.Throttler(0),this._scale=0,this._active=!1,this.reset()}static _createTextureForImage(e,t){const r=e.createTexture();return r.image=t,e.bindTexture(e.TEXTURE_2D,r),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,1),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r.image),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.bindTexture(e.TEXTURE_2D,null),r}reset(){this._tilesByLayer&&this.setLayerTree(null),this._tilesByLayer=new Map,this._queue=[]}setContext(e){this._gl=e,this._scale&&this._updateTextures()}suspend(){this._active=!1}resume(){this._active=!0,this._queue.length&&this._update()}setLayerTree(e){const t=new Set,r=Array.from(this._tilesByLayer.keys());e&&e.forEachLayer(e=>{e.drawsContent()&&(t.add(e),this._tilesByLayer.has(e)||(this._tilesByLayer.set(e,[]),this.layerNeedsUpdate(e)))}),r.length||this.forceUpdate();for(const e of r)t.has(e)||(this._tilesByLayer.get(e).forEach(e=>e.dispose()),this._tilesByLayer.delete(e))}_setSnapshotsForLayer(e,t){const r=new Map((this._tilesByLayer.get(e)||[]).map(e=>[e.snapshot,e])),i=[],s=[];for(const e of t){const t=r.get(e);t?(s.push(t),r.delete(t)):i.push(new Tile(e))}this._tilesByLayer.set(e,s.concat(i));for(const e of r.values())e.dispose();return this._gl&&this._scale?Promise.all(i.map(e=>e.update(this._gl,this._scale))).then(this._textureUpdatedCallback):Promise.resolve()}setScale(e){this._scale&&this._scale>=e||(this._scale=e,this._updateTextures())}tilesForLayer(e){return this._tilesByLayer.get(e)||[]}layerNeedsUpdate(e){this._queue.indexOf(e)<0&&this._queue.push(e),this._active&&this._throttler.schedule(this._update.bind(this))}forceUpdate(){this._queue.forEach(e=>this._updateLayer(e)),this._queue=[],this._update()}_update(){const e=this._queue.shift();return e?(this._queue.length&&this._throttler.schedule(this._update.bind(this)),this._updateLayer(e)):Promise.resolve()}_updateLayer(e){return Promise.all(e.snapshots()).then(t=>this._setSnapshotsForLayer(e,t.filter(e=>!!e)))}_updateTextures(){if(this._gl&&this._scale)for(const e of this._tilesByLayer.values())for(const t of e){const e=t.updateScale(this._gl,this._scale);e&&e.then(this._textureUpdatedCallback)}}}export class Rectangle{constructor(e){this.relatedObject=e,this.lineWidth=1,this.borderColor=null,this.fillColor=null,this.texture=null}setVertices(e,t){this.vertices=[e[0],e[1],t,e[2],e[3],t,e[4],e[5],t,e[6],e[7],t]}_calculatePointOnQuad(e,t,r){const i=e[0],s=e[1],o=e[2],a=e[3],n=e[4],l=e[5],h=e[6],c=e[7],_=i+t*(o-i),d=s+t*(a-s);return[_+r*(h+t*(n-h)-_),d+r*(c+t*(l-c)-d)]}calculateVerticesFromRect(e,t,r){const i=e.quad(),s=t.x/e.width(),o=(t.x+t.width)/e.width(),a=t.y/e.height(),n=(t.y+t.height)/e.height(),l=this._calculatePointOnQuad(i,s,a).concat(this._calculatePointOnQuad(i,o,a)).concat(this._calculatePointOnQuad(i,o,n)).concat(this._calculatePointOnQuad(i,s,n));this.setVertices(l,r)}intersectWithLine(e,t,r){let i;const s=[];for(i=0;i<4;++i)s[i]=UI.Geometry.multiplyVectorByMatrixAndNormalize(new UI.Geometry.Vector(this.vertices[3*i],this.vertices[3*i+1],this.vertices[3*i+2]),e);const o=UI.Geometry.crossProduct(UI.Geometry.subtract(s[1],s[0]),UI.Geometry.subtract(s[2],s[1])),a=o.x,n=o.y,l=o.z,h=-(-(a*s[0].x+n*s[0].y+l*s[0].z)+a*t+n*r)/l,c=new UI.Geometry.Vector(t,r,h),_=s.map(UI.Geometry.subtract.bind(null,c));for(i=0;i<_.length;++i){if(UI.Geometry.scalarProduct(o,UI.Geometry.crossProduct(_[i],_[(i+1)%_.length]))<0)return}return h}}export class Tile{constructor(e){this.snapshot=e.snapshot,this.rect=e.rect,this.scale=0,this.texture=null}dispose(){this.snapshot.release(),this.texture&&(this._gl.deleteTexture(this.texture),this.texture=null)}updateScale(e,t){return this.texture&&this.scale>=t?null:this.update(e,t)}async update(e,t){this._gl=e,this.scale=t;const r=await this.snapshot.replay(t),i=r?await UI.UIUtils.loadImage(r):null;this.texture=i?LayerTextureManager._createTextureForImage(e,i):null}}