import{NodeURL}from"./NodeURL.js";export const ProtocolError=Symbol("Protocol.Error");export const DevToolsStubErrorCode=-32015;const _GenericError=-32e3,_ConnectionClosedErrorCode=-32001;export class InspectorBackend{constructor(){this._agentPrototypes=new Map,this._dispatcherPrototypes=new Map,this._initialized=!1}static reportProtocolError(e,t){console.error(e+": "+JSON.stringify(t))}isInitialized(){return this._initialized}_addAgentGetterMethodToProtocolTargetPrototype(e){let t=0;for(;t<e.length&&e[t].toLowerCase()!==e[t];)++t;const s=e.substr(0,t).toLowerCase()+e.slice(t)+"Agent";TargetBase.prototype[s]=function(){return this._agents[e]},TargetBase.prototype["register"+e+"Dispatcher"]=function(t){this.registerDispatcher(e,t)}}_agentPrototype(e){return this._agentPrototypes.has(e)||(this._agentPrototypes.set(e,new _AgentPrototype(e)),this._addAgentGetterMethodToProtocolTargetPrototype(e)),this._agentPrototypes.get(e)}_dispatcherPrototype(e){return this._dispatcherPrototypes.has(e)||this._dispatcherPrototypes.set(e,new _DispatcherPrototype),this._dispatcherPrototypes.get(e)}registerCommand(e,t,s){const r=e.split(".");this._agentPrototype(r[0]).registerCommand(r[1],t,s),this._initialized=!0}registerEnum(e,t){const s=e.split("."),r=s[0];Protocol[r]||(Protocol[r]={}),Protocol[r][s[1]]=t,this._initialized=!0}registerEvent(e,t){const s=e.split(".")[0];this._dispatcherPrototype(s).registerEvent(e,t),this._initialized=!0}wrapClientCallback(e,t,s,r){return function(o,n){if(o)return console.error(t+o),void e(r);e(s?new s(n):n)}}}let _factory,SendRawMessageCallback;export class Connection{constructor(){this._onMessage}setOnMessage(e){}setOnDisconnect(e){}sendRawMessage(e){}disconnect(){throw new Error("not implemented")}static setFactory(e){_factory=e}static getFactory(){return _factory}}export const test={dumpProtocol:null,deprecatedRunAfterPendingDispatches:null,sendRawMessage:null,suppressRequestErrors:!1,onMessageSent:null,onMessageReceived:null};export class SessionRouter{constructor(e){this._connection=e,this._lastMessageId=1,this._pendingResponsesCount=0,this._domainToLogger=new Map,this._sessions=new Map,this._pendingScripts=[],test.deprecatedRunAfterPendingDispatches=this._deprecatedRunAfterPendingDispatches.bind(this),test.sendRawMessage=this._sendRawMessageForTesting.bind(this),this._connection.setOnMessage(this._onMessage.bind(this)),this._connection.setOnDisconnect(e=>{const t=this._sessions.get("");t&&t.target.dispose(e)})}registerSession(e,t,s){if(s)for(const e of this._sessions.values())if(e.proxyConnection){console.error("Multiple simultaneous proxy connections are currently unsupported");break}this._sessions.set(t,{target:e,callbacks:new Map,proxyConnection:s})}unregisterSession(e){const t=this._sessions.get(e);if(t){for(const e of t.callbacks.values())SessionRouter.dispatchConnectionError(e);this._sessions.delete(e)}}_getTargetBySessionId(e){const t=this._sessions.get(e||"");return t?t.target:null}_nextMessageId(){return this._lastMessageId++}connection(){return this._connection}sendMessage(e,t,s,r,o){const n={},i=this._nextMessageId();if(n.id=i,n.method=s,r&&(n.params=r),e&&(n.sessionId=e),test.dumpProtocol&&test.dumpProtocol("frontend: "+JSON.stringify(n)),test.onMessageSent){const o=JSON.parse(JSON.stringify(r||{}));test.onMessageSent({domain:t,method:s,params:o,id:i},this._getTargetBySessionId(e))}++this._pendingResponsesCount;const c=this._sessions.get(e);c&&(c.callbacks.set(i,o),this._connection.sendRawMessage(JSON.stringify(n)))}_sendRawMessageForTesting(e,t,s){const r=e.split(".")[0];this.sendMessage("",r,e,t,s||(()=>{}))}_onMessage(e){if(test.dumpProtocol&&test.dumpProtocol("backend: "+("string"==typeof e?e:JSON.stringify(e))),test.onMessageReceived){const t=JSON.parse("string"==typeof e?e:JSON.stringify(e));test.onMessageReceived(t,this._getTargetBySessionId(t.sessionId))}const t="string"==typeof e?JSON.parse(e):e;let s=!1;for(const e of this._sessions.values())e.proxyConnection&&(e.proxyConnection._onMessage?(e.proxyConnection._onMessage(t),s=!0):InspectorBackend.reportProtocolError("Protocol Error: the session has a proxyConnection with no _onMessage",t));const r=t.sessionId||"",o=this._sessions.get(r);if(o){if(!o.proxyConnection)if(o.target._needsNodeJSPatching&&NodeURL.patch(t),"id"in t){const e=o.callbacks.get(t.id);if(o.callbacks.delete(t.id),!e)return void(s||InspectorBackend.reportProtocolError("Protocol Error: the message with wrong id",t));e(t.error,t.result),--this._pendingResponsesCount,this._pendingScripts.length&&!this._pendingResponsesCount&&this._deprecatedRunAfterPendingDispatches()}else{if(!("method"in t))return void InspectorBackend.reportProtocolError("Protocol Error: the message without method",t);const e=t.method.split("."),s=e[0];if(!(s in o.target._dispatchers))return void InspectorBackend.reportProtocolError(`Protocol Error: the message ${t.method} is for non-existing domain '${s}'`,t);o.target._dispatchers[s].dispatch(e[1],t)}}else s||InspectorBackend.reportProtocolError("Protocol Error: the message with wrong session id",t)}_deprecatedRunAfterPendingDispatches(e){e&&this._pendingScripts.push(e),setTimeout(()=>{this._pendingResponsesCount?this._deprecatedRunAfterPendingDispatches():this._executeAfterPendingDispatches()},0)}_executeAfterPendingDispatches(){if(!this._pendingResponsesCount){const e=this._pendingScripts;this._pendingScripts=[];for(let t=0;t<e.length;++t)e[t]()}}static dispatchConnectionError(e){const t={message:"Connection is closed, can't dispatch pending call",code:-32001,data:null};setTimeout(()=>e(t,null),0)}}export class TargetBase{constructor(e,t,s,r){if(this._needsNodeJSPatching=e,this._sessionId=s,!t&&r||!t&&s||r&&s)throw new Error("Either connection or sessionId (but not both) must be supplied for a child target");let o;o=s&&t&&t._router?t._router:new SessionRouter(r||_factory()),this._router=o,o.registerSession(this,this._sessionId),this._agents={};for(const[e,t]of inspectorBackend._agentPrototypes)this._agents[e]=Object.create(t),this._agents[e]._target=this;this._dispatchers={};for(const[e,t]of inspectorBackend._dispatcherPrototypes)this._dispatchers[e]=Object.create(t),this._dispatchers[e]._dispatchers=[]}registerDispatcher(e,t){this._dispatchers[e]&&this._dispatchers[e].addDomainDispatcher(t)}dispose(e){this._router&&(this._router.unregisterSession(this._sessionId),this._router=null)}isDisposed(){return!this._router}markAsNodeJSForTest(){this._needsNodeJSPatching=!0}router(){return this._router}auditsAgent(){throw new Error("Implemented in InspectorBackend.js")}cacheStorageAgent(){throw new Error("Implemented in InspectorBackend.js")}debuggerAgent(){throw new Error("Implemented in InspectorBackend.js")}domdebuggerAgent(){throw new Error("Implemented in InspectorBackend.js")}heapProfilerAgent(){throw new Error("Implemented in InspectorBackend.js")}layerTreeAgent(){throw new Error("Implemented in InspectorBackend.js")}memoryAgent(){throw new Error("Implemented in InspectorBackend.js")}networkAgent(){throw new Error("Implemented in InspectorBackend.js")}pageAgent(){throw new Error("Implemented in InspectorBackend.js")}performanceAgent(){throw new Error("Implemented in InspectorBackend.js")}runtimeAgent(){throw new Error("Implemented in InspectorBackend.js")}serviceWorkerAgent(){throw new Error("Implemented in InspectorBackend.js")}storageAgent(){throw new Error("Implemented in InspectorBackend.js")}targetAgent(){throw new Error("Implemented in InspectorBackend.js")}webAuthnAgent(){throw new Error("Implemented in InspectorBackend.js")}registerAuditsDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}registerDebuggerDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}registerDOMDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}registerHeapProfilerDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}registerNetworkDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}registerPageDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}registerStorageDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}registerServiceWorkerDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}registerTargetDispatcher(e){throw new Error("Implemented in InspectorBackend.js")}}class _AgentPrototype{constructor(e){this._replyArgs={},this._domain=e,this._target}registerCommand(e,t,s){const r=this._domain+"."+e;this[e]=function(e){const s=Array.prototype.slice.call(arguments);return _AgentPrototype.prototype._sendMessageToBackendPromise.call(this,r,t,s)},this["invoke_"+e]=function(e={}){return this._invoke(r,e)},this._replyArgs[r]=s}_prepareParameters(e,t,s,r){const o={};let n=!1;for(const i of t){const c=i.name,a=i.type,d=i.optional;if(!s.length&&!d)return r(`Protocol Error: Invalid number of arguments for method '${e}' call. It must have the following arguments ${JSON.stringify(t)}'.`),null;const p=s.shift();if(!d||void 0!==p){if(typeof p!==a)return r(`Protocol Error: Invalid type of argument '${c}' for method '${e}' call. It must be '${a}' but it is '${typeof p}'.`),null;o[c]=p,n=!0}}return s.length?(r(`Protocol Error: Extra ${s.length} arguments in a call to method '${e}'.`),null):n?o:null}_sendMessageToBackendPromise(e,t,s){let r;const o=this._prepareParameters(e,t,s,(function(e){console.error(e),r=e}));return r?Promise.resolve(null):new Promise(t=>{const s=(s,r)=>{if(s)return test.suppressRequestErrors||-32015===s.code||-32e3===s.code||-32001===s.code||console.error("Request "+e+" failed. "+JSON.stringify(s)),void t(null);const o=this._replyArgs[e];t(r&&o.length?r[o[0]]:void 0)};this._target._router?this._target._router.sendMessage(this._target._sessionId,this._domain,e,o,s):SessionRouter.dispatchConnectionError(s)})}_invoke(e,t){return new Promise(s=>{const r=(t,r)=>{t&&!test.suppressRequestErrors&&-32015!==t.code&&-32e3!==t.code&&-32001!==t.code&&console.error("Request "+e+" failed. "+JSON.stringify(t)),r||(r={}),t?(r[ProtocolError]=t.message,r.getError=()=>t.message):r.getError=()=>{},s(r)};this._target._router?this._target._router.sendMessage(this._target._sessionId,this._domain,e,t,r):SessionRouter.dispatchConnectionError(r)})}}class _DispatcherPrototype{constructor(){this._eventArgs={},this._dispatchers}registerEvent(e,t){this._eventArgs[e]=t}addDomainDispatcher(e){this._dispatchers.push(e)}dispatch(e,t){if(!this._dispatchers.length)return;if(!this._eventArgs[t.method])return void InspectorBackend.reportProtocolError(`Protocol Error: Attempted to dispatch an unspecified method '${t.method}'`,t);const s=[];if(t.params){const e=this._eventArgs[t.method];for(let r=0;r<e.length;++r)s.push(t.params[e[r]])}for(let r=0;r<this._dispatchers.length;++r){const o=this._dispatchers[r];e in o&&(o.usesObjectNotation&&o.usesObjectNotation()?o[e].call(o,{...t.params}):o[e].apply(o,s))}}}export let _Callback;export const inspectorBackend=new InspectorBackend;