"use strict";async function taskTool(s,t,n){const i=[],r=[];let e=0;const a=function(){if(e===n.length)return Promise.resolve();const o=n[e],h=Promise.resolve().then((()=>o()));return i.push(h),r.push(h),e+=1,r.length>=s?Promise.race(r).then((()=>(r.splice(r.indexOf(h),1),a()))).catch((s=>{if(t)throw s;return r.splice(r.indexOf(h),1),a()})):a()};return a().then((()=>Promise.all(i)))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.TaskManager=void 0;class TaskManager{constructor(s={}){this.breakWhenError=!0;const{poolLimit:t=50,breakWhenError:n=!0}=s;this._tasks=[],this.poolLimit=t,this.breakWhenError=n,this.isRuning=!1,this.taskPool=null}static get shared(){return this._instance||(this._instance=new this),this._instance}addTask(s,...t){this._tasks.push(s.bind(null,...t))}async runAllAsync(s){if(!this._tasks.length)return[];if(this.isRuning)return this.taskPool;let t;try{this.isRuning=!0,this.taskPool=taskTool(s||this.poolLimit,this.breakWhenError,this._tasks),t=await this.taskPool}catch(s){throw console.log("runAllAsync error:",s),s}finally{this.isRuning=!1,this.taskPool=null,this._tasks=[]}return t}async runAllSerial(){const s=[];try{for(let t=0,n=this._tasks.length;t<n;t++){const n=await this._tasks[t]();s.push(n)}}catch(s){}finally{this._tasks=[]}return s}}exports.TaskManager=TaskManager;