"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const cp=require("child_process");class IdleCP{constructor(e,s,t,h){this.execPath=e,this.args=s,this.logger=t,this.isVerbose=h,this._executed=!1,this._scheduleTs=0,this.onCPClose=(e,s)=>{this._executed?this.verbose("Idle CP Close Already executed"):(this.verbose("Idle CP Close",e,s,Date.now()-this._scheduleTs),this._executed=!0,this._statusCode=e,this._statusSignal=s,this._cp=null,0!==e&&this.logger.e("Idle CP Exit with code",e,s))},this.schedule()}get verbose(){return this.isVerbose?this.logger.i:()=>{}}get statusCode(){return this._executed||this.scheduleSync(),this._statusCode}get statusSignal(){return this._executed||this.scheduleSync(),this._statusSignal}scheduleSync(){if(!this._executed){this.verbose("Idle CP sync schedule"),this._scheduleTs=Date.now();try{const e=cp.spawnSync(this.execPath,this.args);this.onCPClose(e.status,e.signal)}catch(e){this.logger.e("Idle CP sync schedule error",e),this.onCPClose(-1,"ERROR")}}}schedule(){this._scheduleTs=Date.now(),this._cp=cp.spawn(this.execPath,this.args),this._cp.on("close",this.onCPClose),this._cp.on("exit",this.onCPClose),this._cp.on("error",(()=>this.onCPClose(-1,"ERROR")))}}function getMsDetector(e,s,t,h){const i=new IdleCP(e,s,t,h);return{detect:()=>0===i.statusCode}}exports.getMsDetector=getMsDetector;