!function(require, directRequire){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MacroConditionCompiler=void 0;const tslib_1=require("tslib"),expression_1=tslib_1.__importDefault(require("../../../../utils/expression")),base_1=require("./base");var IfType;!function(e){e[e.If=0]="If",e[e.Elif=1]="Elif"}(IfType||(IfType={}));const deleteFlag="-----mini-delete-flag-----";let useTripleSlash;class IfBlock{constructor(e,s,t=[],i=null,n=[]){this.startIx=e,this.endIx=s,this.elifIxs=t,this.elseIx=i,this.innerIfs=n}getIfRange(){const e=this.elifIxs.length>0?this.elifIxs[0]:null!==this.elseIx?this.elseIx:this.endIx;return[this.startIx,e]}getElifRange(e){if(this.elifIxs.length>e){return[this.elifIxs[e],this.elifIxs.length>e+1?this.elifIxs[e+1]:null!==this.elseIx?this.elseIx:this.endIx]}throw new Error(`Invalid elif index '${e}', there are only ${this.elifIxs.length} elifs.`)}getElseRange(){if(null!==this.elseIx)return[this.elseIx,this.endIx];throw new Error("Cannot use elseRange when elseIx is null.")}}class MacroConditionCompiler extends base_1.BaseConditionCompiler{constructor(){super(...arguments),this.getIFRegex=()=>".wxml"===this.type?/^[\s]*<!--[\s]*#(if|elif)[\s]+([\s\S]+)-->[\s]*$/g:".wxss"===this.type?/^[\s]*\/\*[\s]*#(if|elif)[\s]+([\s\S]+)\*\/[\s]*$/g:useTripleSlash?/^[\s]*\/\/\/[\s]*#(if|elif)[\s]+([\s\S]+)$/g:/^[\s]*\/\/[\s]*#(if|elif)[\s]+([\s\S]+)$/g,this.getELSERegex=()=>".wxml"===this.type?/^[\s]*<!--[\s]*#(else)[\s]*-->[\s]*$/g:".wxss"===this.type?/^[\s]*\/\*[\s]*#(else)[\s]*\*\/[\s]*$/g:useTripleSlash?/^[\s]*\/\/\/[\s]*#(else)[\s]*$/g:/^[\s]*\/\/[\s]*#(else)[\s]*$/g,this.getENDIFRegex=()=>".wxml"===this.type?/^[\s]*<!--[\s]*#(endif)[\s]*-->[\s]*$/g:".wxss"===this.type?/^[\s]*\/\*[\s]*#(endif)[\s]*\*\/[\s]*$/g:useTripleSlash?/^[\s]*\/\/\/[\s]*#(endif)[\s]*$/g:/^[\s]*\/\/[\s]*#(endif)[\s]*$/g,this.getFefineRegex=()=>".wxml"===this.type?/^[\s]*<!--[\s]*#define[\s]+(\S+)[\s]+(\S+)[\s]*-->[\s]*$/g:".wxss"===this.type?/^[\s]*\/\*[\s]*#define[\s]+(\S+)[\s]+(\S+)[\s]*\*\/[\s]*$/g:useTripleSlash?/^[\s]*\/\/\/[\s]*#define[\s]+(\S+)[\s]+(\S+)[\s]*$/g:/^[\s]*\/\/[\s]*#define[\s]+(\S+)[\s]+(\S+)[\s]*$/g}getFileDefines(e){if(-1===e.indexOf("#define"))return{};const s=e.split("\n"),t={};for(let e=0;e<s.length;e++)if(this.matchDefine(s[e])){const{key:i,val:n}=this.parseDefine(s[e]);t[i]=n}return t}matchDefine(e){return null!==this.getFefineRegex().exec(e)}parseDefine(e){const s=this.getFefineRegex().exec(e);if(s)return{key:s[1].trim(),val:s[2].trim()};throw new Error(`Could not parse #if: '${e}'.`)}applyDefines(e){for(let s=0;s<e.length;s++)this.matchDefine(e[s])&&(e[s]=deleteFlag)}findIFBlocks(e){const s=[];for(let t=0;t<e.length;t++)if(this.matchIF(e[t])){const i=this.parseIFBlock(e,t);s.push(i),t=i.endIx}return s}parseIFBlock(e,s){const t=[];let i,n=null;const l=[];for(let r=s+1;r<e.length;r++){const s=e[r];if(this.matchIF(s)){const s=this.parseIFBlock(e,r);l.push(s),r=s.endIx;continue}if(this.matchIF(s,IfType.Elif)){t.push(r);continue}if(this.matchELSE(s)){n=r;continue}if(this.matchENDIF(s)){i=r;break}}if(void 0===i)throw new Error(`#if without #endif on line ${s+1}.`);return new IfBlock(s,i,t,n,l)}matchIF(e,s=IfType.If){const t=this.getIFRegex().exec(e);return null!==t&&(s===IfType.If&&"if"===t[1]||s===IfType.Elif&&"elif"===t[1])}parseIF(e){const s=this.getIFRegex().exec(e);if(s)return s[2].trim();throw new Error(`Could not parse #if: '${e}'.`)}matchENDIF(e){const s=this.getENDIFRegex().exec(e);return Boolean(s)}matchELSE(e){const s=this.getELSERegex().exec(e);return Boolean(s)}applyIF(e,s,t,i=!1,n){let l=null;const r=this.parseIF(e[s.startIx]),o=(e,t)=>{if(i)throw new Error(`#if block lines [${s.startIx+1}-${s.endIx+1}]: Condition '${e}' is ${t?"TRUE":"FALSE"}. ${null!==l?`Including lines [${l[0]+1}-${l[1]+1}]`:"Excluding everything"} (${n})`)};if(this.evaluate(r,t))l=s.getIfRange(),o(r,!0);else{for(let i=0;i<s.elifIxs.length;i++){const n=e[s.elifIxs[i]],r=this.parseIF(n);if(this.evaluate(r,t)){l=s.getElifRange(i),o(r,!0);break}}null===l&&(null!==s.elseIx&&(l=s.getElseRange()),o(r,!1))}null!==l?(this.blankCode(e,s.startIx,l[0]),this.blankCode(e,l[1],s.endIx)):this.blankCode(e,s.startIx,s.endIx);for(const i of s.innerIfs)null!==l&&i.startIx>=l[0]&&i.startIx<=l[1]&&this.applyIF(e,i,t,this.verbose)}evaluate(e,s){let t;e=e.replace(/defined\(([a-z0-9]*)\)/gi,(e,s)=>`(typeof ${s} !== "undefined")`);try{t=new expression_1.default(e).parse()(s)}catch(e){t=!1}return t}blankCode(e,s,t=s){for(let i=s;i<=t;i++)e[i]=deleteFlag}doCompile(e){const{filePath:s,content:t,macroDefine:i}=e;try{const e=t.toString(),n=this.getFileDefines(e),l=Object.assign(Object.assign({},i.getDefines()),n);void 0===this.tripleSlash&&(this.tripleSlash=!1),useTripleSlash=this.tripleSlash;const r=e.split("\n");if(this.applyDefines(r),-1!==t.indexOf("#if")){const e=this.findIFBlocks(r);for(const t of e)this.applyIF(r,t,l,this.verbose,s)}return r.filter(e=>e!==deleteFlag).join("\n")}catch(e){throw new Error(`[PreCompiler]compile ${s} error:${e.message}`)}}}exports.MacroConditionCompiler=MacroConditionCompiler;
}(require("licia/lazyImport")(require), require)