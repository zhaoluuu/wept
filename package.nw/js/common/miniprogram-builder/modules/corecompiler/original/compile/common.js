!function(require, directRequire){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getUploadProjectConfig=exports.compileWXMLFiles=exports.compileWXSSFiles=exports.compileJSFiles=exports.compileOther=exports.isNotIgnoredByProjectConfig=exports.getBabelRoot=void 0;const tslib_1=require("tslib"),path_1=tslib_1.__importDefault(require("path")),tools_1=require("../../../../utils/tools"),taskstatus_1=require("../../../../utils/taskstatus"),index_1=require("../workerThread/index"),babel_helper_1=require("../../../../utils/babel_helper"),projectconfig_1=require("../json/projectconfig"),game_1=tslib_1.__importDefault(require("../json/game")),signaturejson_1=require("../json/signaturejson"),config_1=require("../../../../config/config"),wxml_1=require("./handler/wxml"),wxss_1=require("./handler/wxss"),js_1=require("./handler/js");async function getBabelRoot(o){var e,t;const i=(0,projectconfig_1.getProjectConfigJSON)(o);let s=null===(t=null===(e=null==i?void 0:i.setting)||void 0===e?void 0:e.babelSetting)||void 0===t?void 0:t.outputPath;return s?(s=(0,tools_1.normalizePath)(s),s.replace(/(^[./\\])|(\/$)/g,""),s):"@babel/runtime"}function isNotIgnoredByProjectConfig(o,e,t){var i,s;const n=path_1.default.posix.relative(e,t),a=(null===(i=o.packOptions)||void 0===i?void 0:i.include)||[];if((0,tools_1.isFileIncluded)(n,a))return!0;const l=(null===(s=o.packOptions)||void 0===s?void 0:s.ignore)||[];return!(0,tools_1.isFileIgnored)(path_1.default.posix.relative(e,t),l)}async function copyFile(o,e){return{filePath:e,code:o.getFile("",e)}}async function compileOther(o,e,t){const{onProgressUpdate:i=(()=>{})}=t,s=new taskstatus_1.TaskStatus("compiling other files");i(s);const n=[];for(const t of e)n.push(copyFile(o,t));const a=await Promise.all(n),l={};for(const o of a){const{code:e,filePath:t}=o;e&&(l[t]=e)}return s.done(),i(s),l}async function canWeCompileJS(o,e,t){let i;for(const o of e)if((0,tools_1.normalizePath)(t).startsWith((0,tools_1.normalizePath)((0,signaturejson_1.trailing)(o.fullPath,"/")))){i=o;break}if(i){return i.signature.findIndex(o=>(0,tools_1.normalizePath)(o.fullPath)===(0,tools_1.normalizePath)(t))>=0}return!0}async function compileJSFiles(o,e,t,i){const{setting:s={}}=i;let n="@babel/runtime";s.es7&&(n=await getBabelRoot(o));const a=[];if(o.type===config_1.COMPILE_TYPE.miniGame||o.type===config_1.COMPILE_TYPE.miniGamePlugin){const s=await(0,signaturejson_1.getAllPluginSignatures)(o);for(const l of e){const e=path_1.default.join(o.projectPath,t,l);await canWeCompileJS(o,s,e)&&a.push((0,js_1.compileJS)(o,l,Object.assign(Object.assign({},i),{babelRoot:n,root:t})))}}else for(const s of e)a.push((0,js_1.compileJS)(o,s,Object.assign(Object.assign({},i),{babelRoot:n,root:t})));let l=[];try{l=await Promise.all(a)}catch(o){throw(0,index_1.abortTask)(index_1.TASK_NAME.COMPILE_JS),o}const r={},c=new Set;for(const o of l){const{filePath:e,map:i,code:s,helpers:n}=o,a=(0,tools_1.formatSourceMap)(i);void 0!==s&&(r[path_1.default.posix.normalize(path_1.default.posix.join(t,e))]=s),a&&(r[path_1.default.posix.normalize(path_1.default.posix.join(t,e+".map"))]=a),n.length>0&&n.forEach(o=>{c.add(o)})}return await(0,babel_helper_1.appendBabelHelpers)(c,path_1.default.join(t),n,r),r}async function compileWXSSFiles(o,e,t,i){const s=[];for(const n of e)s.push((0,wxss_1.compileWXSS)(o,n,Object.assign(Object.assign({},i),{root:t})));let n=[];try{n=await Promise.all(s)}catch(o){throw(0,index_1.abortTask)(index_1.TASK_NAME.COMPILE_WXSS),o}const a={};for(const o of n){const{filePath:e,code:i}=o;void 0!==i&&(a[path_1.default.posix.normalize(path_1.default.posix.join(t,e))]=i)}return a}async function compileWXMLFiles(o,e,t,i){const s=[];for(const n of e)s.push((0,wxml_1.compileWXML)(o,n,Object.assign(Object.assign({},i),{root:t})));let n=[];try{n=await Promise.all(s)}catch(o){throw(0,index_1.abortTask)(index_1.TASK_NAME.MINIFY_WXML),o}const a={};for(const o of n){const{filePath:e,code:i}=o;void 0!==i&&(a[path_1.default.posix.normalize(path_1.default.posix.join(t,e))]=i)}return a}async function getUploadProjectConfig(o,e){const t={miniprogramRoot:e.miniprogramRoot,localPlugins:[]};e.pluginRoot&&(t.pluginRoot=e.pluginRoot);const i=(0,game_1.default)(o),s=(o,e="")=>{const i=t.localPlugins||[];for(const t in o)if(o.hasOwnProperty(t)&&o[t]&&"string"==typeof o[t].path){const s=o[t],n=path_1.default.posix.normalize(path_1.default.posix.join(e,s.path.replace(/\\/g,"/")).replace(/^\/+/,""));i.push({alias:t,provider:s.provider,path:n})}t.localPlugins=i};if(i.plugins){const{plugins:o}=i;s(o)}const n=i.subpackages||i.subPackages;if(Array.isArray(n))for(const o of n)(null==o?void 0:o.plugins)&&s(o.plugins,o.root||"");return t}exports.getBabelRoot=getBabelRoot,exports.isNotIgnoredByProjectConfig=isNotIgnoredByProjectConfig,exports.compileOther=compileOther,exports.compileJSFiles=compileJSFiles,exports.compileWXSSFiles=compileWXSSFiles,exports.compileWXMLFiles=compileWXMLFiles,exports.getUploadProjectConfig=getUploadProjectConfig;
}(require("licia/lazyImport")(require), require)