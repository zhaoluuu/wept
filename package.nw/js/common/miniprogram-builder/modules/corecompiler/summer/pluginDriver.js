!function(require, directRequire){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PluginDriver=exports.getPluginContext=exports.genResovleExtConf=void 0;const customError_1=require("../../../utils/customError"),workerThread_1=require("../original/workerThread");function genResovleExtConf(r){const o={json:["json"],wxml:["wxml"],wxss:["wxss"],js:["js"],wxs:["wxs"]};for(const t of r)if(t.resolveExt)for(const r of["json","wxml","wxss","js","wxs"]){const e=t.resolveExt[r];if("string"==typeof e)o[r].includes(e)||o[r].push(e);else if(Array.isArray(e))for(const t of e)o[r].includes(t)||o[r].push(t)}return o}function throwPluginError(r,o,{hook:t,id:e}={}){const s=(0,customError_1.makeCustomError)(r);throw s.code||(s.code=customError_1.CustomErrors.SUMMER_PLUGIN_ERR),s.plugin=o,t&&(s.hook=t),e&&!s.path&&(s.path=e),r.stack&&(s.stack=r.stack),s}function getPluginContext(r,o){return{addWatchFile(){throw new Error("addWatchFile should be implemented by replaceContext")},async runWorkerMethod(t,...e){const s=await o.project.serialize(),n={command:"runMethod",plugin:r.name,projectInfo:s,pluginOption:{},method:t,args:e},i=await(0,workerThread_1.runTask)(workerThread_1.TASK_NAME.SUMMER_HOOK,n);if(i.error){if("CustomError"===i.error.type)throw new customError_1.CustomError(i.error);throw i.error}return i.result},error:o=>throwPluginError(o,r.name)}}exports.genResovleExtConf=genResovleExtConf,exports.getPluginContext=getPluginContext;class PluginDriver{constructor(r,o){this.graph=r,this.options=o,this.pluginContexts=new Map,this.plugins=o.plugins,this.resolveExtConf=genResovleExtConf(o.plugins);for(const o of this.plugins)this.pluginContexts.set(o,getPluginContext(o,r))}runHook(r,o,t,e){const s=t[r];if(!s)return;let n=this.pluginContexts.get(t);return e&&(n=e(n,t)),Promise.resolve().then(()=>s.apply(n,o)).catch(o=>throwPluginError(o,t.name,{hook:r}))}hookFirst(r,o,t){let e=Promise.resolve(void 0);for(const s of this.plugins)e=e.then(e=>null!=e?e:this.runHook(r,o,s,t));return e}hookParallel(r,o,t){const e=[];for(const s of this.plugins){const n=this.runHook(r,o,s,t);n&&e.push(n)}return Promise.all(e).then(()=>{})}hookReduceArg0(r,[o,...t],e,s){let n=Promise.resolve(o);for(const o of this.plugins)n=n.then(n=>{const i=[n,...t],u=this.runHook(r,i,o,s);return u?u.then(r=>e.call(this.pluginContexts.get(o),n,r,o)):n});return n}}exports.PluginDriver=PluginDriver;
}(require("licia/lazyImport")(require), require)