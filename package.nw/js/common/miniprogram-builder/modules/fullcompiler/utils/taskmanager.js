!function(require, directRequire){
"use strict";async function taskTool(t,s,i){const n=[],r=[];let e=0;const a=function(){if(e===i.length)return Promise.resolve();const h=i[e],o=Promise.resolve().then(()=>h());return n.push(o),r.push(o),e+=1,r.length>=t?Promise.race(r).then(()=>(r.splice(r.indexOf(o),1),a())).catch(t=>{if(s)throw t;return r.splice(r.indexOf(o),1),a()}):a()};return a().then(()=>Promise.all(n))}class TaskManager{constructor(t={}){this.breakWhenError=!0;const{poolLimit:s=50,breakWhenError:i=!0}=t;this._tasks=[],this.poolLimit=s,this.breakWhenError=i,this.isRuning=!1,this.taskPool=null}static get shared(){return this._instance||(this._instance=new this),this._instance}addTask(t,...s){this._tasks.push(t.bind(null,...s))}async runAllAsync(t){if(!this._tasks.length)return[];if(this.isRuning)return this.taskPool;let s;try{this.isRuning=!0,this.taskPool=taskTool(t||this.poolLimit,this.breakWhenError,this._tasks),s=await this.taskPool}catch(t){throw t}finally{this.isRuning=!1,this.taskPool=null,this._tasks=[]}return s}async runAllSerial(){const t=[];try{for(let s=0,i=this._tasks.length;s<i;s++){const i=await this._tasks[s]();t.push(i)}}catch(t){}finally{this._tasks=[]}return t}}module.exports=TaskManager;
}(require("licia/lazyImport")(require), require)