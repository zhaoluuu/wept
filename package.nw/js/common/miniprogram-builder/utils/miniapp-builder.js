!function(require, directRequire){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.checkXcodeEnv=exports.codesignAndExport=exports.signAndInstallOrExport=exports.doCertificateSignAndInstallOrExport=exports.doAppleIdSignAndInstallOrExport=exports.clearCache=exports.getIOSDevices=exports.miniappSinTypes=exports.DEFAULT_BUNDLE_ID=void 0;const tslib_1=require("tslib"),child_process=tslib_1.__importStar(require("child_process")),singletontask_1=require("./singletontask"),zip_1=require("./zip"),cp_1=require("./cp"),tools_1=require("./tools"),download_1=require("./download"),glob_1=tslib_1.__importDefault(require("glob")),miniappJson_1=require("./miniappJson"),path=require("path"),os=require("os"),fse=require("fs-extra"),querystring=require("querystring");exports.DEFAULT_BUNDLE_ID="com.tencent.devtoolssaaademo.db";const isMac="darwin"===process.platform,remoteUrlRoot="http://dldir1.qq.com/WechatWebDev/donut/miniapp-builder/";exports.miniappSinTypes={appleId:{type:"appleId"},certificate:{type:"certificate"}};const majorVersion="0",signAndInstallTask={};async function generateIpa(e,n){let t="";if(e.endsWith(".app")){const i=path.dirname(e);t=path.join(os.tmpdir(),"miniapp-unsigned.ipa"),null==n||n.progress("pack the ipa..."),fse.existsSync(t)&&fse.removeSync(t),await(0,zip_1.archiveZip)(path.dirname(i),t)}else{if(!e.endsWith(".ipa"))throw new Error("invalid ipa/.app file");t=e}return t}async function getMiniAppBuilderVersion(e="cli"){try{"dev"!==e&&"cli"!==e&&(e="release-0");const n=`${remoteUrlRoot}versionMap/${e}.json`,t=path.join(os.tmpdir(),"miniapp-builder-version.json");fse.existsSync(t)&&fse.removeSync(t),await(0,download_1.downloadLargeFile)(n,t);const i=fse.readJSONSync(t);return isMac?i.mac:i.win}catch(e){throw new Error("getMiniAppBuilderVersion fail: "+e.message)}}async function downloadMiniAppBuilder(e,n,t){const i=`${remoteUrlRoot}${isMac?"mac":"win"}/miniapp-builder-${e}.zip`,s=path.join(os.tmpdir(),"miniapp-builder.zip");fse.existsSync(s)&&fse.removeSync(s),null==t||t.progress("Downloading the miniapp-builder..."),await(0,download_1.downloadLargeFile)(i,s),await(0,zip_1.unzip)(s,n)}async function getMiniAppBuilder(e){const{miniappDirPath:n=path.join(__dirname,"../vendor"),devtoolsVersion:t="cli",recorder:i}=e,s=await getMiniAppBuilderVersion(t);let a="";const r=path.join(n,"miniapp-builder");if(a="win32"===process.platform?(0,tools_1.unifyPath)(path.join(r,s,"MiniappBuilder.exe")):(0,tools_1.unifyPath)(path.join(r,s,"MiniAppBuilder")),!fse.existsSync(a)){fse.ensureDirSync(r),fse.emptyDirSync(r);const e=path.dirname(a);fse.ensureDirSync(e),await downloadMiniAppBuilder(s,e,i);glob_1.default.sync("*",{nodir:!0,cwd:e}).forEach(n=>{fse.chmodSync(path.join(e,n),"777")})}return{builderPath:a,exe:path.basename(a),cwd:path.dirname(a)}}async function getIOSDevices(e){const{builderPath:n}=await getMiniAppBuilder(e),t=child_process.execSync(`"${n}" --action getDevices`,{}).toString().split("\n"),i=[];return t.forEach(e=>{if(e.trim()){const n=e.split("|");i.push({type:"device",name:(n[1]||"").trim(),version:(n[2]||"").trim(),udid:(n[3]||"").trim()})}}),i}async function clearCache(e){const{builderPath:n}=await getMiniAppBuilder(e);child_process.execSync(`"${n}" --action clear --type ${e.type}`,{})}async function doAppleIdSignAndInstallOrExport(e,n){const{recorder:t}=n,{exe:i,cwd:s,builderPath:a}=await getMiniAppBuilder(n),r=(0,tools_1.unifyPath)(e.ipaPath),p=["--action","sign","--ipa",r,"--type","appleId"];if(e.appleId&&p.push("-ai",e.appleId),e.password&&p.push("-p",e.password),e.entitlements&&p.push("--entitlements",querystring.stringify(e.entitlements)),e.install&&(isMac?p.push("--install"):p.push("--install","true")),e.deviceId&&p.push("--deviceId",e.deviceId),e.output&&p.push("--output",e.output),e.bundleId){const n=e.bundleId===exports.DEFAULT_BUNDLE_ID?"auto":e.bundleId;p.push("--bundleId",n)}try{return signAndInstallTask[r]||(signAndInstallTask[r]=isMac?new singletontask_1.SingletonTask(cp_1.spawnSync.bind(null,a,p,{},t)):new singletontask_1.SingletonTask(cp_1.spawnSync.bind(null,i,p,{cwd:s},t))),await signAndInstallTask[r].getResult(!0),{success:!0}}catch(e){return{success:!1,errMsg:e.message}}finally{delete signAndInstallTask[r]}}async function doCertificateSignAndInstallOrExport(e,n){const{recorder:t}=n,{exe:i,cwd:s,builderPath:a}=await getMiniAppBuilder(n),r=(0,miniappJson_1.tryGetIOSMiniappJson)(e.projectPath),p=(0,miniappJson_1.iOSMiniAppJsonIsUsingTpush)(r),o=(0,tools_1.unifyPath)(e.ipaPath),l=["--action","sign","--ipa",o,"--type","certificate"];e.entitlements&&l.push("--entitlements",querystring.stringify(e.entitlements)),e.install&&(isMac?l.push("--install"):l.push("--install","true")),p&&(isMac?l.push("--extensionProfilePath"):l.push("--extension","true")),e.deviceId&&l.push("--deviceId",e.deviceId),e.output&&l.push("--output",e.output);try{return signAndInstallTask[o]||(signAndInstallTask[o]=isMac?new singletontask_1.SingletonTask(cp_1.spawnSync.bind(null,a,l,{},t)):new singletontask_1.SingletonTask(cp_1.spawnSync.bind(null,i,l,{cwd:s},t))),await signAndInstallTask[o].getResult(!0),{success:!0}}catch(e){return{success:!1,errMsg:e.message}}finally{delete signAndInstallTask[o]}}async function signAndInstallOrExport(e,n,t,i,s){const{recorder:a}=s,{install:r,deviceId:p,output:o,entitlements:l,bundleId:c}=i,d=await generateIpa(n,a);try{null==a||a.progress("signing the app...");const{signType:n}=t;let i=null;if(i=n===exports.miniappSinTypes.appleId.type?await doAppleIdSignAndInstallOrExport({bundleId:c,projectPath:e,ipaPath:d,entitlements:l,install:r,output:o,deviceId:p},s):await doCertificateSignAndInstallOrExport({projectPath:e,ipaPath:d,entitlements:l,install:r,output:o,deviceId:p},s),!i.success)throw new Error("Sign the app fail:"+i.errMsg)}finally{fse.existsSync(d)&&fse.removeSync(d)}}async function codesignAndExport(e,n,t,i,s){var a;const{output:r}=t,{recorder:p}=i,o=path.join(__dirname,"../static/scripts/resignIpa"),l=await generateIpa(n,p),c=(null===(a=t.entitlements)||void 0===a?void 0:a["com.apple.developer.associated-domains"])||"";try{await checkXcodeEnv(p);const e=[l,r,s?"true":"",c];return signAndInstallTask[l]||(signAndInstallTask[l]=new singletontask_1.SingletonTask(cp_1.spawnSyncExecShell.bind(null,o,e,{},p))),await signAndInstallTask[l].getResult(!0),{success:!0}}catch(e){return{success:!1,errMsg:e.message}}finally{delete signAndInstallTask[l]}}async function checkXcodeEnv(e){const n=path.join(__dirname,"../static/scripts/checkXcodeEnv");await(0,cp_1.spawnSyncExecShell)(n,[],{},e)}exports.getIOSDevices=getIOSDevices,exports.clearCache=clearCache,exports.doAppleIdSignAndInstallOrExport=doAppleIdSignAndInstallOrExport,exports.doCertificateSignAndInstallOrExport=doCertificateSignAndInstallOrExport,exports.signAndInstallOrExport=signAndInstallOrExport,exports.codesignAndExport=codesignAndExport,exports.checkXcodeEnv=checkXcodeEnv;
}(require("licia/lazyImport")(require), require)