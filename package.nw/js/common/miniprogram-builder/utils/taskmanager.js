!function(require, directRequire){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const AbortEvent="TaskManagerAborted";function taskTool(t,s,o){const r=[],e=[];let n=0,a=!1;const i=function(){if(n===o.length)return Promise.resolve();if(a)throw console.log(`!!!! task pool aborted, ${o.length-n} task not execute`),AbortEvent;const l=o[n],h=Promise.resolve().then(()=>l());return r.push(h),e.push(h),n+=1,e.length>=t?Promise.race(e).then(()=>(e.splice(e.indexOf(h),1),i())).catch(t=>{if(s)throw t;return e.splice(e.indexOf(h),1),i()}):i()};return{run:i().then(()=>Promise.all(r)),abort:function(){a=!0}}}class TaskManager{constructor(t={}){this.breakWhenError=!0;const{poolLimit:s=10,breakWhenError:o=!0}=t;this._tasks=[],this.poolLimit=s,this.breakWhenError=o,this.taskPool=null}static get shared(){return this._instance||(this._instance=new this),this._instance}addTask(t,...s){this._tasks.push(t.bind(null,...s))}async runAllAsync(t){if(!this._tasks.length)return[];if(this.taskPool)return this.taskPool.run;let s;try{this.taskPool=taskTool(t||this.poolLimit,this.breakWhenError,this._tasks),s=await this.taskPool.run}catch(t){throw console.log("runAllAsync error:",t),t}finally{this.taskPool=null,this._tasks=[]}return s}async abortAsyncTask(){this.taskPool&&(this.taskPool.abort(),this.taskPool=null,this._tasks=[])}async runAllSerial(){const t=[];try{for(let s=0,o=this._tasks.length;s<o;s++){const o=await this._tasks[s]();t.push(o)}}catch(t){}finally{this._tasks=[]}return t}}exports.default=TaskManager;
}(require("licia/lazyImport")(require), require)